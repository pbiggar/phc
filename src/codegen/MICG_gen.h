/*
 * phc -- the open source php compiler
 * see doc/license/readme.license for licensing information
 *
 * Macro-Inline Code Generator (pronounced 'mig', like wig)
 */

#ifndef PHC_MICG_GEN
#define PHC_MICG_GEN

#include "MICG.h"

#include "lib/String.h"
#include "lib/Map.h"

#define MICG_TRUE "TRUE"
#define MICG_FALSE "FALSE"
namespace MICG
{

class Symtable : public Map<string, Object*>
{
public:
	// Each of these returns a String or Node. If coerce is set, a Node will
	// be converted to a String with convert_to_string. Booleans are always
	// converted.
	Object* get_lookup (Lookup*, bool coerce = false);
	Object* get_param (PARAM_NAME*, bool coerce = false);

	// Convert an Object to a String:
	//		Booleans are converted to MICG_TRUE/MICG_FALSE
	//		Identifiers are converted using get_value_as_string.
	//		Other Objects are converted to "true" (this allows lookups to
	//		succeed if they find anything).
	static String* convert_to_string (Object*);

	// Return a string representation of the list. This should never fail, and
	// is primarily for debugging.
	static String* to_string_rep (Object_list*);
};

}

class MICG_gen
{
	// callback_t: A function which takes a string and returns a string.
	typedef string (*callback_t)(string);
	Map<string, callback_t> callbacks;
	Map<string, MICG::Macro_list> macros;

public:
	void add_macro (MICG::Macro*);
	void add_macro_def (string str, string filename);


	// It is difficult to call this with variadic arguments. va_list wont work,
	// and overloading operators is hassle. The simplest thing is just to have
	// one signature of each length we need, and assume we wont need more thn 8
	// arguments or so.
	string instantiate (string macro_name, Object_list* params);
	string instantiate (string macro_name, Object* param1);
	string instantiate (string macro_name, Object* param1, Object* param2);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3, Object* param4);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3, Object* param4, Object* param5);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3, Object* param4, Object* param5, Object* param6);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3, Object* param4, Object* param5, Object* param6,
			Object* param7);
	string instantiate (string macro_name, Object* param1, Object* param2,
			Object* param3, Object* param4, Object* param5, Object* param6,
			Object* param7, Object* param8);

	// Check that the signature matches (its not called 'matches' to avoid
	// overloading the word 'match', which is generated by maketea).
	bool suitable (MICG::Macro* sig, Object_list* params);

	// Give an error if OBJ cannot be coerced to TYPE.
	void check_type (MICG::TYPE_NAME* type_name, Object* obj);

	// Get the macro named NAME, whose rules match PARAMs.
	MICG::Macro* get_macro (string name, Object_list* params);

	// Actually substitute the parameters into the body.
	string instantiate_body (MICG::Body* body, MICG::Symtable* symtable);

	MICG::Symtable* get_symtable (string macro_name, MICG::Formal_parameter_list*, Object_list*);

	Object* get_expr (MICG::Expr* expr, MICG::Symtable* symtable, bool coerce = false);
	Object_list* get_expr_list (MICG::Expr_list* exprs, MICG::Symtable* symtable, bool coerce = false);


	string callback (string name, String* param);
	void register_callback (string name, callback_t callback);

	// Wrappers around common calls. The parameters are fetched from SYMTABLE
	// using their actual parameters in MC and CB.
	String* exec (MICG::Macro_call* mc, MICG::Symtable* symtable);
	String* exec (MICG::Callback* cb, MICG::Symtable* symtable);
};



#endif // PHC_MICG_GEN
