#!/usr/bin/perl

use strict;
use Cwd;

my $cwd = getcwd();
my $match = shift or "";

my $max = 0;
my %regrdirs;

# note: this apes the first portion of the runregr script; changes to one
# should be reflected in the other

sub addregrs;
sub addregrs {
    my $dir = shift;
    return if (-e "$dir/ignore");

    my $regr = substr($dir,length($cwd)+1,length($dir));
    if ((-e "$dir/run") && (-e "$dir/expected.txt")) {
        if ($regr =~ /$match/ || $match eq "") {
            $regr = "current" if ($regr eq "");
            $regrdirs{$regr} = $dir;
            $max = length($regr) if (length($regr) > $max);
        }
    }

    opendir(DIR,$dir);
    my @subdirs = readdir(DIR);
    closedir(DIR);

    for my $subdir (@subdirs) {
        if (-d "$dir/$subdir" && not ($subdir =~ /^[.]/)) {
            addregrs "$dir/$subdir";
        }
    }
}
addregrs $cwd;

my $start = time();

foreach my $regr (sort keys %regrdirs) {
    printf("%-*s", $max + 3, "$regr:");

    chdir("$regrdirs{$regr}");

    system("rm *.db *.dot 2> /dev/null");
    if (system("./run > regr.out.txt") != 0) {
        print "CRASHED\n";
        exit 0;
    }
    system("cat regr.out.txt | sort | uniq > regr.sort.txt");
    system("cat expected.txt | sort | uniq > regr.exp.txt");
    system("diff regr.sort.txt regr.exp.txt > regr.diff.txt");

    open(IN,"< regr.diff.txt");
    my @diff = <IN>;
    close(IN);

    system("cp regr.sort.txt expected.txt");
    print "SET\n";

    foreach my $line (@diff) {
        print $line;
    }

    system("rm *.db *.dot regr.*.txt 2> /dev/null");
}

my $total = time() - $start;
print "Total time: $total seconds\n";
