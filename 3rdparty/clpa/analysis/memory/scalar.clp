%%
% Authors:
%   Peter Hawkins  <hawkinsp@cs.stanford.edu>
%
% Copyright (c) 2006,
%   The Board of Trustees of The Leland Stanford Junior University
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice,
% this list of conditions and the following disclaimer.
% 
% 2. Redistributions in binary form must reproduce the above copyright notice,
% this list of conditions and the following disclaimer in the documentation
% and/or other materials provided with the distribution.
% 
% 3. The names of the contributors may not be used to endorse or promote
% products derived from this software without specific prior written
% permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%%

%-----------------------------------------------------------------------------%
% scalar.clp
%
% Integer/float operations with a high level symbolic representation.
%
% This is useful in combination with scalar_sat which handles SAT conversion
% and constraint solving.
%
%-----------------------------------------------------------------------------%

%-----------------------------------------------------------------------------%
% Interface
%-----------------------------------------------------------------------------%

import "memory.clp".
using solve_sat.
using map.

% ----------------------------------------------------------------------------
% Scalar expressions and guard representation

type scalar.
type scalar_cmp.

    % Names for unconstrained trace values.
type g_xvrep.
type g_vecrep ::=
        % Initial value of some trace at entry point to a summary.
      vr_t{t_trace}             

        % Initial values of a soft trace. Since in general a soft trace
        % represents a set of values, we need to allow for the possibility for
        % different references to the trace's initial value referring to 
        % distinct memory locations. We use the program point and expression 
        % (if any) of the access site to obtain a unique name for each access, 
        % thereby simulating the fact that each access may return a different 
        % element of the set.
    | vr_st{t_trace, pp, maybe[c_exp]}        
    
        % Imprecise intermediate result. These are generated by operations that
        % we don't model and instead treat as uninterpreted functions.
    | vr_i{pp, c_exp}           

        % Unconstrained value of a trace after being clobbered by a call or 
        % loop side-effect.
    | vr_c{sum, pp, t_trace}

        % Result of mapping an imprecise or clobbered value using inst_scalar.
        % Some unconstrained values can't be sensibly renamed when mapping
        % a scalar out of a callsite. To give a name to such values we
        % use the following recursive constructor to name the value by the 
        % callsite.
    | vr_instscalar{sum, pp, g_vecrep}

        % Vectors for extension by client analyses. Note that the client must
        % also implement predicates inst_scalar_xvrep, scalar_string_x, and
        % map_scalar for these extra vectors.
    | vr_extra{g_xvrep}

    % Values not generated by scalar.clp
    | vr_buffersize{t_trace}    % Size of a buffer in bytes

    % Values generated by scalar_sat.clp
    | vr_u{scalar}              % Unmodelled expression treated as an 
                                % uninterpreted function. 
    .

    % Representation for regular unconstrained bits, which can be the bits used
    % by the memory analysis, or the extra type g_xrep for extension by
    % client analyses
type g_xrep.
type g_arep ::=
       % Bits created for use by memory analysis
      ar_path{pp, pp}
    | ar_entry{pp, t_trace, t_trace}
    | ar_exit{sum, pp, t_trace, t_trace}
    | ar_clobber{sum, pp, t_trace}
    | ar_instguard{sum, pp, g_arep}

       % Bits for extension by client analyses. Note that the client must
       % also implement predicates inst_scalar_xrep, arep_string_x, and
       % map_guard for these extra bits.
    | ar_extra{g_xrep}
    .

    % Guard leaf formulae
type g_bit ::= 
      br_cmp{scalar_cmp}    % Result of a scalar comparison operation
    | br_ioverflow{scalar}  % Overflow bit of an integer expression
    | br_abit{g_arep}       % Additional bit created by memory/client analyses

    .

% ----------------------------------------------------------------------------

    % A scalar with a guard attached.
type guarded_scalar = t_pair[scalar, g_guard].

    % A set of guarded scalars. We use a map here so we can group similar 
    % scalars with different guards.
type guarded_scalar_set = map[scalar, g_guard].

    % The possible kinds of scalar expressions.
type t_scalar_kind ::= 
      sk_int{Signed:bool, Bits:int} 
    | sk_float{Bits:int}.

    % Vector associated with a kind
type vecrep_kind = t_pair[g_vecrep,t_scalar_kind].

type scalar_unop.
type scalar_binop.

    % An scalar expression
    % Width fields are given as a number of bits
type scalar ::=
        % Integer and floating point constants
      s_int_const{int, Signed:bool, Bits:int}   
    | s_float_const{float, Bits:int}

        % Uninterpreted int/float expressions which represent something we 
        % can't model directly, such as the initial value of a variable or 
        % the value of an inexact operation. 
    | s_unconstrained{g_vecrep, t_scalar_kind} 

    | s_cast{scalar, t_scalar_kind}             % Signedness and/or width cast
    | s_guard{guarded_scalar_set}               % A list of guarded integer 
                                                % expressions

    | s_unop{scalar_unop, scalar}               % Unary operations
    | s_binop{scalar_binop, scalar, scalar}     % Binary operations

    .

    % Unary integer operations
type scalar_unop ::=
      su_neg                                % Unary negation
    | su_not                                % Binary negation
    .

    % Binary integer operations
type scalar_binop ::=
      sb_plus                               % Addition
    | sb_minus                              % Subtraction
    | sb_mul                                % Multiplication
    | sb_div                                % Division
    | sb_mod                                % Modulus
    | sb_shiftlt                            % Left shift
    | sb_shiftrt                            % Right shift
    | sb_or                                 % Disjunction
    | sb_and                                % Conjunction
    | sb_xor                                % eXclusive OR
    .

    % Integer comparisons
type t_scalar_cmp ::=
      sc_eq     % ==
    | sc_ne     % !=
    | sc_lt     % <
    | sc_le     % <=
    | sc_gt     % >
    | sc_ge     % >=
    .

    % scalar_cmp_op(SC, Str, Prec) holds for each possible sc_... constant.
    % Str is a string representation of the comparison operator, and Prec
    % is a relative operator precedence.
predicate scalar_cmp_op(t_scalar_cmp, string, int).

    % cil_cmp_binop_to_scalar_cmp(Op, SC)
    % Map CIL comparison ops to our types
predicate cil_cmp_binop_to_scalar_cmp(out binop, out t_scalar_cmp).

type scalar_cmp ::=
      sc{t_scalar_cmp, scalar, scalar}
    | sc_eqz{scalar}        % Shorthand for 0 == ...
    .

    % Intermediate integer/floating-point values are scalars
type t_nrep = scalar.

% ----------------------------------------------------------------------------
% Publically exported predicates 

    % evals(P, E, I)
    % At program point P, expression E evaluates to scalar I
predicate evals(in pp, in c_exp, out scalar).

    % vals(P, T, IE)
    % At program point P, trace T has scalar value IE
predicate vals(in pp, in t_trace, out scalar).

    % inst_guard(I, P, RG, NG)
    % As interpreted by the call/loop I at point P, callee guard RG maps to 
    % caller guard NG
predicate inst_guard(in sum, in pp, in g_guard, out g_guard) succeeds [once].

    % inst_scalar(I, P, RI, NI)
    % As interpreted by the call/loop I at point P, callee scalar RI maps to
    % caller scalar NI
predicate inst_scalar(in sum, in pp, in scalar, out scalar) succeeds [once].

    % predicates for use by clients in extending inst_scalar/inst_guard
    % to handle extra vectors or bits being inserted by the client
predicate inst_scalar_xvrep(in sum, in pp, t_scalar_kind, in g_xvrep,
                            out scalar, out WG:g_guard)
    succeeds [many].
predicate inst_scalar_xrep(in sum, in pp, in g_xrep,
                           out g_guard, out WG:g_guard)
    succeeds [many].

    % td_inst_guard(I, P, RG, NG, WG)
    % Within call/loop I at point P, caller guard RG maps to callee guard NG
    % when additional caller guard WG holds
predicate td_inst_guard(in sum, in pp, in g_guard, out g_guard, out g_guard).

    % td_inst_scalar(I, P, RI, NI, WG)
    % Within call/loop I at point P, caller scalar RI maps to callee scalar NI
    % when additional caller guard WG holds
predicate td_inst_scalar(in sum, in pp, in scalar, out scalar, out g_guard).

% applies simple constant folding etc. to a scalar, preserving its input
% if no simplifications could be applied
predicate simplify_scalar(in scalar, out scalar) succeeds [once].
predicate simplify_scalar_cmp(in scalar_cmp, out g_guard) succeeds [once].

% pieces of a scalar, guard, or trace to pick out
type s_used ::=
    su_scalar{scalar}
  | su_bit{g_bit}.

    % xyz_used(I, V)
    % Value V is referenced by scalars or guards contained within I
predicate scalar_used(in scalar,out s_used).
predicate bit_used(in g_bit,out s_used).
predicate guard_used(in g_guard,out s_used).
predicate trace_used(in t_trace,out s_used).

    % xyz_trace_used(I, T)
    % Trace T is referenced by I
predicate scalar_trace_used(in scalar, out t_trace).
predicate bit_trace_used(in g_bit, out t_trace).
predicate guard_trace_used(in g_guard, out t_trace).
predicate trace_trace_used(in t_trace, out t_trace).

% ----------------------------------------------------------------------------

    % Given a scalar, determine its kind.
predicate scalar_kind(in scalar, out t_scalar_kind) succeeds [once].

    % How many bits are needed to represent a given scalar kind?
predicate scalar_kind_nbits(in t_scalar_kind, out int) succeeds [once].

    % Given a trace, determine its kind.
predicate trace_scalar_kind(in sum, in t_trace, out t_scalar_kind)
    succeeds [once].

    % Given a type, determine whether it is a scalar type (ie. an int, float
    % or enum).
predicate type_scalar(in t_type).

    % Given a type, determine the corresponding scalar_kind that should be
    % used to represent it.
    % NB. Some non-scalar types (e.g. pointers) will be assigned kinds
    % by this predicate.
predicate type_scalar_kind(in t_type, out t_scalar_kind) succeeds [zero,once].

    % traceval_scalar(P, V, Kind, IE)
    % Convert a trace_val V at program point P to an scalar expression IE.
    % The initial value of traces at function or loop entry is an 
    % unconstrained vector, or the integer expression itself in
    % other cases. Takes a program point and optional expression in order
    % to uniquely name different occurrences of soft traces.
predicate traceval_scalar(in pp, in maybe[c_exp], in t_trace_val, 
    in t_scalar_kind, out scalar).

% ----------------------------------------------------------------------------
% Guard construction predicates

% Equivalents of bv_eqz, bv_nez, bv_lt, bv_gt etc
predicate g_eqz(in IE: scalar,                out G:g_guard) succeeds [once].
predicate g_nez(in IE: scalar,                out G:g_guard) succeeds [once].
predicate g_eq( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].
predicate g_ne( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].
predicate g_gt( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].
predicate g_lt( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].
predicate g_le( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].
predicate g_ge( in IE1:scalar, in IE2:scalar, out G:g_guard) succeeds [once].

operator '==' = g_eq.
operator '!=' = g_ne.
operator '<' = g_lt.
operator '<=' = g_le.
operator '>' = g_gt.
operator '>=' = g_ge.

    % g_cmp(Op, S1, S2, G)
    % Produce a comparison guard between two scalars using the specified
    % operator.
predicate g_cmp(in t_scalar_cmp, in IE1:scalar, in IE2:scalar, 
    out G:g_guard) succeeds [once].

    % g_range(S, Min, Max, G)
    % Produce a guard G that holds if S is between Min and Max inclusive.
    % Only defined for integer-valued scalars.
predicate g_range(in scalar, in int, in int, out g_guard) succeeds [once].

    % Extract the overflow bit of an integer expression
predicate g_intoverflow(in scalar, out g_guard) succeeds [once].

% ----------------------------------------------------------------------------
% Scalar construction predicates

    % Create a scalar value representing an integer constant.
    % The scalar size will be chosen to be large enough to represent
    % the integer value without overflow.
predicate sc_int(in int, out scalar).

    % Cast a scalar to a different kind
predicate sc_cast(in scalar, in t_scalar_kind, out scalar).

    % Given a list of guarded scalars, simplify the list
    % if possible and return a single scalar representing the set.
predicate sc_guarded(in list[guarded_scalar], out scalar).

% ----------------------------------------------------------------------------
% Generic guard/scalar transformation

% these predicates provide a user-extendable mechanism to map guards
% and scalars to each other using one-to-one transformations.
% the abstract type ts_map describes the possible ways to map a guard,
% and should be extended by clients to include the operations they want to do.
% the try_map_* predicates describe the effects of these maps, the result
% of applying the transform to a particular guard or scalar.
% the try_map_* predicates need not be defined for all guards or scalars.
%
% the behavior map_* is to use the result of try_map_* if it is defined
% (if REAPPLY is set to another map, then that map will be be run over
% the result of try_map_* to get the actual result), and if try_map_* is
% not defined then map_* will be recursively applied to sub-guards/scalars.

% Example usage:
% replace all occurrences of a particular trace within a guard or scalar
%
% type ts_xmap ::= ts_reptrace{RT:t_trace,NT:t_trace}.
% try_map_scalar(ts_extra{ts_reptrace{RT,NT}},RS,NS) :-
%     RS=s_unconstrained{vr_t{RBT},Kind},
%     trace_sub(RBT,RT,XT), trace_compose(s_func,NT,XT,NBT),
%     NS=s_unconstrained{vr_t{NBT},Kind}.
% try_map_scalar(ts_extra{ts_reptrace{RT,NT}},RS,NS) :-
%     RS=s_unconstrained{vr_st{RBT,P,E},Kind},
%     trace_sub(RBT,RT,XT), trace_compose(s_func,NT,XT,NBT),
%     NS=s_unconstrained{vr_st{NBT,P,E},Kind}.
%
% then a trace RT can be replaced with NT within any guard RG or scalar RS:
% ..., map_guard(ts_reptrace{RT,NT},RG,NG), ...
% ..., map_scalar(ts_reptrace{RT,NT},RS,NS), ...
%
% note that ts_reptrace is already defined as a possible mapping...

type ts_xmap.  % client-extensible mappings for guards/scalars
type ts_map ::=
    ts_reptrace{RT:t_trace,NT:t_trace}
  | ts_repscalar{RS:scalar,NS:scalar}
  | ts_vbreplace{VMAP:map[vecrep_kind,scalar],BMAP:map[g_arep,g_guard]}
  | ts_extra{ts_xmap}.

predicate try_map_guard(in ts_map,in RG:g_guard,
                        NG:g_guard,REAPPLY:maybe[ts_map]) succeeds [zero,once].
predicate try_map_scalar(in ts_map,in RS:scalar,
                         NS:scalar,REAPPLY:maybe[ts_map]) succeeds [zero,once].
predicate try_map_bit(in ts_map,in RB:g_bit,
                      NG:g_guard,REAPPLY:maybe[ts_map]) succeeds [zero,once].

predicate map_guard(in ts_map,in RG:g_guard,NG:g_guard) succeeds [once].
predicate map_scalar(in ts_map,in RS:scalar,NS:scalar) succeeds [once].
predicate map_bit(in ts_map,in RB:g_bit,NG:g_guard) succeeds [once].

% preserves form of trace, just runs map_scalar over any array offset indexes
predicate map_trace(in ts_map,in RT:t_trace,NT:t_trace) succeeds [once].

% ----------------------------------------------------------------------------
% Stringification

predicate guard_string(in g_guard, out string) succeeds [once].
predicate scalar_string(in scalar, out string) succeeds [once].
predicate scalar_cmp_string(in scalar_cmp, out string) succeeds [once].

% ----------------------------------------------------------------------------

    % If debug_scalar is defined, warn on failure of predicates such as eval
predicate debug_scalar().

    % Don't clobber scalars as a result of call/loop side effects.
predicate no_clobber_scalars().

    % sum_write(Sum, T)
    % Summary Sum or its callees may write to trace T.
predicate sum_write(sum, t_trace).

% ----------------------------------------------------------------------------
% Implementation.
% ----------------------------------------------------------------------------

scalar_cmp_op(sc_eq, "==", 5) :- .
scalar_cmp_op(sc_ne, "!=", 5) :- .
scalar_cmp_op(sc_lt, "<", 6) :- .
scalar_cmp_op(sc_le, "<=", 6) :- .
scalar_cmp_op(sc_ge, ">=", 6) :- .
scalar_cmp_op(sc_gt, ">", 6) :- .

cil_cmp_binop_to_scalar_cmp(b_eq, sc_eq) :- .
cil_cmp_binop_to_scalar_cmp(b_ne, sc_ne) :- .
cil_cmp_binop_to_scalar_cmp(b_lt, sc_lt) :- .
cil_cmp_binop_to_scalar_cmp(b_gt, sc_gt) :- .
cil_cmp_binop_to_scalar_cmp(b_le, sc_le) :- .
cil_cmp_binop_to_scalar_cmp(b_ge, sc_ge) :- .

% ----------------------------------------------------------------------------

g_eqz(RES, G)     :- simplify_scalar_cmp(sc_eqz{RES}, G).
g_nez(RES, NG)    :- simplify_scalar_cmp(sc_eqz{RES}, G), #not(G, NG).
g_eq(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_eq, IE1, IE2}, G).
g_ne(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_ne, IE1, IE2}, G).
g_lt(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_lt, IE1, IE2}, G).
g_gt(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_gt, IE1, IE2}, G).
g_le(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_le, IE1, IE2}, G).
g_ge(IE1, IE2, G) :- simplify_scalar_cmp(sc{sc_ge, IE1, IE2}, G).

g_cmp(Cmp, IE1, IE2, G) :- simplify_scalar_cmp(sc{Cmp, IE1, IE2}, G).

g_range(S, Min, Max, G) :-
    scalar_kind(S, sk_int{Signed, Bits}),
    nrep_cmp(b_ge, S, s_int_const{Min, Signed, Bits}, G1),
    nrep_cmp(b_le, S, s_int_const{Max, Signed, Bits}, G2),
    #and(G1, G2, G).

g_intoverflow(IE, G) :- #id_g(br_ioverflow{IE}, G).

% ----------------------------------------------------------------------------

    % nbits(N, Bits)
    % Non-negative integer N can be represented exactly using Bits bits.
predicate nbits(in int, out int).

nbits(0, 0) :- .
nbits(N, B) :-
    int_gt(N, 0),
    int_div(N, 2, N2),
    nbits(N2, B2),
    int_add(B2, 1, B).

    % Negative integer constant to scalar
sc_int(N, s_int_const{N, true, NBits}) :-
    int_lt(N, 0),
    int_neg(N, M),
    nbits(M, MBits),
    int_add(MBits, 1, NBits).

    % Positive integer constant to scalar
sc_int(N, s_int_const{N, false, NBits}) :-
    int_ge(N, 0),
    nbits(N, NBits).

% ----------------------------------------------------------------------------

sc_cast(S0, Kind, S0) :-
    scalar_kind(S0, OldKind),
    OldKind = Kind.

sc_cast(S0, Kind, S) :-
    scalar_kind(S0, OldKind),
    OldKind \= Kind,
    simplify_scalar(s_cast{S0, Kind}, S).

% ----------------------------------------------------------------------------

predicate guarded_scalar_list_to_map(in list[guarded_scalar],
    in guarded_scalar_set, out guarded_scalar_set).

predicate trivial_guarded_expr(in guarded_scalar_set, out scalar).

sc_guarded(GS, T) :-
    map_empty(M0),
    guarded_scalar_list_to_map(GS, M0, M),
    trivial_guarded_expr(M, T).

sc_guarded(GS, s_guard{M}) :-
    map_empty(M0),
    guarded_scalar_list_to_map(GS, M0, M),
    ~trivial_guarded_expr(M, _).

guarded_scalar_list_to_map([], M, M) :- .
guarded_scalar_list_to_map([pair{S, G0}|GSs], M0, M) :-
    map_search(M0, S, G1),
    #or(G0, G1, G),
    map_insert(S, G, M0, M1),
    guarded_scalar_list_to_map(GSs, M1, M).

guarded_scalar_list_to_map([pair{S, G}|GSs], M0, M) :-
    ~map_search(M0, S, _),
    map_insert(S, G, M0, M1),
    guarded_scalar_list_to_map(GSs, M1, M).

trivial_guarded_expr(M, I) :-
    map_to_sorted_list(M, [pair{I, G}]),
    #bool_g(true, G).

% ----------------------------------------------------------------------------
% Unconstrained bits for upstream analyses 

path_bit(P0, P1, G) :- #id_g(br_abit{ar_path{P0, P1}}, G).
entry_bit(P, S, T, G) :- #id_g(br_abit{ar_entry{P, S, T}}, G).
exit_bit(SUM, P, S, T, G) :- #id_g(br_abit{ar_exit{SUM, P, S, T}}, G).

% ----------------------------------------------------------------------------
% Value clobbering through call/loop side effects.

import "mustmod.clp".

predicate clobber_bit(in sum, in pp, in t_trace, out g_guard).

    % Must-mod traces are always clobbered.
clobber_bit(SUM, P, T, G) :- 
    ~inst_mustmod(SUM, T),
    #id_g(br_abit{ar_clobber{SUM, P, T}}, G).
clobber_bit(SUM, P, T, G) :- 
    inst_mustmod(SUM, T),
    #bool_g(true, G).

predicate clobber(in sum, in pp, t_trace, t_trace, t_scalar_kind, g_guard).

    % Scalar call side-effects. Requires precise usemod information.
    % For every scalar valued trace possibly modified by a call, introduce a new
    % unconstrained value for the value of the trace after the call.
    % We don't handle return values here since they already have temporary
    % values created for them by the CFG construction code.
clobber(ISum, P0, ST, T, Kind, FG) :-
    ~no_clobber_scalars(),
    sum_body(Sum, P0),
    inst_usemod(ISum, ST, write),
    ST \= root{return},
    inst_trace(ISum, P0, ST, trace{T}, G),
    trace_type(Sum, T, Type),
    type_scalar(Type),
    type_scalar_kind(Type, Kind),
    clobber_bit(ISum, P0, ST, CG),
    #and(CG, G, FG). 

inst_transfer_necessary(ISum, P0, T, PG) :-
    isum(P0, _, ISum),
    clobber(ISum, P0, _, T, _, FG),
    #not(FG, PG). % By Demorgan's law PG = (not CG) or (not G)

vmerge(P1, T, nrep{s_unconstrained{vr_c{ISum, P0, ST}, Kind}}, FG) :-
    isum(P0, P1, ISum),
    clobber(ISum, P0, ST, T, Kind, G),
    eguard(P0, P1, G, FG).

% ----------------------------------------------------------------------------

    % Values clobbered by callers are written in the summary
sum_write(Sum, T) :-
    isum(P0, _, ISum),
    clobber(ISum, P0, _, T, _, _),
    sum_body(Sum, P0).

    % Values directly modified by the summary are modified in the summary
sum_write(Sum, T) :-
    access(P, T, write),
    sum_body(Sum, P).

% ----------------------------------------------------------------------------

type_scalar(y_int{_}) :- .
type_scalar(y_flt{_}) :- .
type_scalar(y_enum{_}) :- .

% ----------------------------------------------------------------------------

scalar_kind_nbits(sk_int{_, Bits}, Bits) :- .
scalar_kind_nbits(sk_float{Bits}, Bits) :- .

type_scalar_kind(y_int{IKind}, sk_int{Signed, Bits}) :-
    ikind_bits(IKind, Signed, Bits).

type_scalar_kind(y_enum{_}, sk_int{Signed, Bits}) :-
    ikind_bits(iint, Signed, Bits).

type_scalar_kind(y_flt{FKind}, sk_float{Bits}) :-
    fkind_bits(FKind, Bits).

type_scalar_kind(y_ptr{_}, sk_int{false, Bits}) :-
    pointer_bits(Bits).

% Whether T representing some trace value is soft. trace_soft fails on
% abstract initial integer values for traces which do not represent
% actual physical locations.
predicate trace_val_soft(in SUM:sum, in T:t_trace).
trace_val_soft(SUM, T) :-
    ~generate_index_traces(), trace_type(SUM, T, _), trace_soft(SUM, T, _).
trace_val_soft(SUM, drf{PT}) :-
    ~generate_index_traces(), ~trace_type(SUM, drf{PT}, _), trace_soft(SUM, PT, _).

% Kinded version
traceval_scalar(P, E, trace{T}, Kind, s_unconstrained{vr_t{T}, Kind}) :- 
    sum_body(Sum, P), ~trace_val_soft(Sum, T).
traceval_scalar(P, E, trace{T}, Kind, s_unconstrained{vr_st{T, P, E}, Kind}) :-
    sum_body(Sum, P), trace_val_soft(Sum, T).

traceval_scalar(_, _, nrep{V}, _Kind, V) :- .

% Kindless version
predicate traceval_scalar_nokind(in t_trace_val, out scalar) succeeds [once].
traceval_scalar_nokind(trace{drf{T}}, s_unconstrained{vr_t{drf{T}}, Kind}) :- 
    trace_type(s_func, T, Type),
    type_scalar_kind(Type, Kind).

traceval_scalar_nokind(trace{drf{T}}, s_unconstrained{vr_t{drf{T}}, sk_int{false, Bits}}) :- 
    ~trace_type(s_func, T, _),
    pointer_bits(Bits).

traceval_scalar_nokind(trace{T}, s_unconstrained{vr_t{T}, sk_int{false, Bits}})
    :- 
    T \= drf{_},
    pointer_bits(Bits).

traceval_scalar_nokind(nrep{V}, V) :- .

%?- trace_type(A,B,C).

trace_scalar_kind(Sum, T, K) :-
    trace_type(Sum, T, Type),
    type_scalar_kind(Type, K).

% ----------------------------------------------------------------------------
% Expression/trace integer values for upstream analyses

trace_nrep(T, V) :- traceval_scalar_nokind(T, V).

% we need to work directly with trace_nrep_exp(), generating unconstrained
% values in cases where the trace is soft
omit_trace_nrep_exp() :- .

% there may be an implicit cast for nrep{}
trace_nrep_exp(_, E, nrep{V}, NV) :-
    exp_type(E, EType), type_bits(EType, S, LEN),
    sc_cast(V, sk_int{S,LEN}, NV).

trace_nrep_exp(P, E, trace{T}, V) :-
    exp_type(E, EType),
    convert_type(EType, Type),
    type_scalar_kind(Type, Kind),
    traceval_scalar(P, yes{E}, trace{T}, Kind, V).

unconstrained_nrep(P, E, s_unconstrained{vr_i{P, E}, Kind}) :-
    exp_type(E, EType),
    convert_type(EType, Type),
    type_scalar_kind(Type, Kind).

% nreps can always be flattened
nrep_flatten(VLIST, V) :- sc_guarded(VLIST, V).

% get the sign/length of an nrep
nrep_bits(V, S, LEN) :- scalar_kind(V, sk_int{S, LEN}).
nrep_bits(V, true, LEN) :- scalar_kind(V, sk_float{LEN}).

% ----------------------------------------------------------------------------
% Scalar nrep operations

% constant integers
nrep_const_int(K, N, I) :-
    ikind_bits(K, Sign, Bits),
    I = s_int_const{N, Sign, Bits}.

% constant floats
nrep_const_flt(K, N, I) :-
    fkind_bits(K, Bits),
    I = s_float_const{N, Bits}.

% casts
nrep_cast(Sign, Bits, CI, I) :-
    sc_cast(CI, sk_int{Sign, Bits}, I).

predicate sunop(out unop, out scalar_unop).
sunop(u_neg,  su_neg) :- .
sunop(u_bnot, su_not) :- .

% unary operations
nrep_unop(OP, RI, I) :-
    sunop(OP, IOP),
    simplify_scalar(s_unop{IOP, RI}, I).

predicate sbinop(out binop, out scalar_binop).
sbinop(b_plusa,   sb_plus) :- .
sbinop(b_band,    sb_and) :- .
sbinop(b_bxor,    sb_xor) :- .
sbinop(b_bor,     sb_or) :- .
sbinop(b_mult,    sb_mul) :- .
sbinop(b_minusa,  sb_minus) :- .
sbinop(b_div,     sb_div) :- .
sbinop(b_mod,     sb_mod) :- .
sbinop(b_shiftlt, sb_shiftlt) :- .
sbinop(b_shiftrt, sb_shiftrt) :- .

% binary operations
nrep_binop(OP, LI, RI, I) :-
    sbinop(OP, IOP),
    simplify_scalar(s_binop{IOP, LI, RI}, I).

% unary comparisons
nrep_nez(I, G) :- simplify_scalar_cmp(sc_eqz{I}, ZG), #not(ZG, G).

% binary comparisons
nrep_cmp(OP, LI, RI, G) :-
    cil_cmp_binop_to_scalar_cmp(OP, IOP),
    simplify_scalar_cmp(sc{IOP, LI, RI}, G).

% ----------------------------------------------------------------------------

predicate inst_trace_scalar_kind(in sum, in pp, in t_scalar_kind, in t_trace, out scalar, out g_guard)
    succeeds [many].

% use inst_trace in cases where the callee trace maps to some caller value
inst_trace_scalar_kind(Sum, P, Kind, CalleeTrace, E, G) :-
    inst_trace(Sum, P, CalleeTrace, TraceVal, G),
    ~#bool_g(false, G),             % Omit trivially false cases
    traceval_scalar(P, no, TraceVal, Kind, E).

% use an unconstrained value where the trace is purely within the scope of the callee:
% data allocated within the callee
% return value ignored by the caller
% argument not passed in by caller
inst_trace_scalar_kind(Sum, P, Kind, CalleeTrace, TS, True) :-
    (~trace_alloc(Sum, CalleeTrace, ak_external);
     trace_root(CalleeTrace, return), Sum=s_call{I}, ~callret(I,_);
     trace_root(CalleeTrace, arg{N}), Sum=s_call{I}, ~cil_instr_call_arg(I,N,_)),
    #bool_g(true, True),
    TS = s_unconstrained{
        vr_instscalar{Sum, P, vr_t{CalleeTrace}},
        Kind
    }.

% use an unconstrained value where the trace referred to is in the caller's scope
% but does not actually exist at the call site (callee referencing contents of a NULL pointer)
inst_trace_scalar_kind(Sum, P, Kind, CalleeTrace, TS, G) :-
    trace_sub(CalleeTrace, SCalleeTrace, RT), RT\=empty,
    inst_trace(Sum, P, SCalleeTrace, nrep{_}, G),
    TS = s_unconstrained{
        vr_instscalar{Sum, P, vr_t{CalleeTrace}},
        Kind
    }.

% -----------------------------------------------------------------------------
% evals - expression conversion

    % eimerge(P, E, IE)
    % IE is a possible value for expression E at program point P
predicate eimerge(in pp, in c_exp, out guarded_scalar).

evals(P, E, I) :-
    eimerge(P, E, _),
    \/eimerge(P, E, IM):list_all(IM, Is),
    sc_guarded(Is, I).

eimerge(P, E, pair{IE, G}) :-
    eval(P, E, V, G),
    exp_type(E, EType),
    convert_type(EType, Type),
    type_scalar_kind(Type, Kind),
    traceval_scalar(P, yes{E}, V, Kind, IE).

% -----------------------------------------------------------------------------
% vals - trace conversion

    % vimerge(P, T, IE)
    % IE is a possible value for trace T at program point P
predicate vimerge(in pp, in t_trace, out guarded_scalar).

vals(P, Trace, I) :-
    vimerge(P, Trace, _),
    \/vimerge(P, Trace, IM):list_all(IM, Is),
    sc_guarded(Is, I).

vimerge(P, T, pair{IE, G}) :-
    val(P, T, V, G),
    trace_type(s_func, T, Type),
    type_scalar_kind(Type, Kind),
    traceval_scalar(P, no, V, Kind, IE).

% -----------------------------------------------------------------------------
% Scalar structure bottom up and top down revaluation

% remap a list of vectors at a call site bottom up or top down accding to BTM
predicate inst_scalar_vector_list(in I:sum,in P:pp,in BTM:bool,
                                  in VLIST:list[vecrep_kind],
                                  VMAP:map[vecrep_kind,scalar],G:g_guard).
inst_scalar_vector_list(_,_,_,[],MAP,TG) :-
    map_empty(MAP), #bool_g(true,TG).
inst_scalar_vector_list(I,P,BTM,[pair{V,K}|TAIL],NMAP,NG) :-
    inst_scalar_vector_list(I,P,BTM,TAIL,MAP,G0),
    (BTM=true, V=vr_t{T}, inst_trace_scalar_kind(I,P,K,T,S,G1);
     BTM=true, V=vr_extra{XV}, inst_scalar_xvrep(I,P,K,XV,S,G1);
     BTM=true, V\=vr_t{_}, V\=vr_extra{_},
         S=s_unconstrained{vr_instscalar{I,P,V},K}, #bool_g(true,G1);
     BTM=false, V=vr_t{T}, td_inst_trace(I,P,T,CT,G1),
         S=s_unconstrained{vr_t{CT},K}),
    map_insert(pair{V,K},S,MAP,NMAP), #and(G0,G1,NG), ~#bool_g(false,NG).

% remap a list of bits at a call site bottom up or top down according to BTM
predicate inst_scalar_bit_list(in I:sum,in P:pp,in BTM:bool,
                               in BLIST:list[g_arep],
                               BMAP:map[g_arep,g_guard],G:g_guard).
inst_scalar_bit_list(_,_,_,[],MAP,TG) :-
    map_empty(MAP), #bool_g(true,TG).
inst_scalar_bit_list(I,P,BTM,[B|TAIL],NMAP,NG) :-
    inst_scalar_bit_list(I,P,BTM,TAIL,MAP,G0),
    (BTM=true, B=ar_extra{XB}, inst_scalar_xrep(I,P,XB,BG,G1);
     BTM=true, B\=ar_extra{_},
         #id_g(br_abit{ar_instguard{I,P,B}},BG), #bool_g(true,G1)),
    map_insert(B,BG,MAP,NMAP), #and(G0,G1,NG).

predicate inst_scalar_map(in I:sum,in P:pp,in BTM:bool,
                          in VLIST:list[vecrep_kind],in BLIST:list[g_arep],
                          MAP:ts_map,G:g_guard).
inst_scalar_map(I,P,BTM,VLIST,BLIST,MAP,G) :-
    inst_scalar_vector_list(I,P,BTM,VLIST,VMAP,G0),
    inst_scalar_bit_list(I,P,BTM,BLIST,BMAP,G1),
    MAP=ts_vbreplace{VMAP,BMAP}, #and(G0,G1,G).

predicate inst_guard_x(in I:sum,in P:pp,in BTM:bool,in RG:g_guard,
                       NG:g_guard,WG:g_guard).
predicate inst_scalar_x(in I:sum,in P:pp,in BTM:bool,in RI:scalar,
                        NI:scalar,WG:g_guard).

inst_guard_x(I,P,BTM,RG,NG,WG) :-
    \/guard_used(RG,su_scalar{s_unconstrained{V,K}}):list_all(pair{V,K},VLIST),
    \/guard_used(RG,su_bit{br_abit{B}}):list_all(B,BLIST),
    inst_scalar_map(I,P,BTM,VLIST,BLIST,MAP,WG), map_guard(MAP,RG,NG).
inst_scalar_x(I,P,BTM,RS,NS,WG) :-
    \/scalar_used(RS,su_scalar{s_unconstrained{V,K}}):list_all(pair{V,K},VLIST),
    \/scalar_used(RS,su_bit{br_abit{B}}):list_all(B,BLIST),
    inst_scalar_map(I,P,BTM,VLIST,BLIST,MAP,WG), map_scalar(MAP,RS,NS).

inst_guard(SUM,P,RG,NG) :-
    \/(inst_guard_x(SUM,P,true,RG,XNG,XWG), #and(XNG,XWG,XG)):#or_all(XG,NG).
inst_scalar(SUM,P,RS,NS) :-
    \/inst_scalar_x(SUM,P,true,RS,XNS,XWG):list_all(pair{XNS,XWG},GSLIST),
    sc_guarded(GSLIST,NS).

td_inst_guard(I,P,RG,NG,WG) :- inst_guard_x(I,P,false,RG,NG,WG).
td_inst_scalar(I,P,RI,NI,WG) :- inst_scalar_x(I,P,false,RI,NI,WG).

% implement inst_trace_val in terms of inst_scalar_x
inst_trace_val(I,P,trace{CT},V,G) :- inst_trace(I,P,CT,V,G).
inst_trace_val(I,P,nrep{CS},nrep{S},G) :- inst_scalar_x(I,P,true,CS,S,G).
td_inst_trace_val(I,P,trace{T},trace{CT},G) :- td_inst_trace(I,P,T,CT,G).
td_inst_trace_val(I,P,nrep{S},nrep{CS},G) :- inst_scalar_x(I,P,false,S,CS,G).

% ----------------------------------------------------------------------------
% Scalar simplification

% try to simplify a scalar. in cases where multiple simplifications can be
% applied, just pick one and continue simplifying. simplifiers should have
% the property that while applying a chain of simplifications, the intermediate
% scalars may vary but the final result is the same (diamond property),
% but regardless the simplifiers preserve equivalence.
predicate try_simplify_scalar(in scalar, out scalar).
simplify_scalar(S,S) :- ~try_simplify_scalar(S,_).
simplify_scalar(S,NS) :- \/try_simplify_scalar(S,XS):list_all(XS,[MS|_]),
    simplify_scalar(MS,NS).

% try to simplify a scalar comparison
predicate try_simplify_scalar_cmp(in scalar_cmp, out g_guard).
simplify_scalar_cmp(S,G) :- try_simplify_scalar_cmp(S,G).
simplify_scalar_cmp(S,G) :- ~try_simplify_scalar_cmp(S,_), #id_g(br_cmp{S},G).

% compute the signed modulus of BN according to SIGN/LEN
predicate signed_modulus(in BN:int, in SIGN:bool, in LEN:int, out N:int).
signed_modulus(BN,false,LEN,N) :-
    int_exp(2,LEN,EXP),
    int_mod(BN,EXP,N).
signed_modulus(BN,true,LEN,N) :-
    int_exp(2,LEN,EXP),
    int_sub(LEN,1,MLEN), int_exp(2,MLEN,MEXP),
    int_mod(BN,EXP,BMN),
    (int_lt(BMN,MEXP), N=BMN;
     int_ge(BMN,MEXP), int_sub(BMN,EXP,N)).

% const-fold casts
try_simplify_scalar(s_cast{CS,sk_int{SIGN,LEN}},S) :-
    CS = s_int_const{CN,_,_},
    signed_modulus(CN,SIGN,LEN,NN),
    S = s_int_const{NN,SIGN,LEN}.

% const-fold unops
try_simplify_scalar(s_unop{su_neg,LS},S) :-
    LS = s_int_const{LN,SIGN,LEN},
    int_sub(0,LN,BN),
    signed_modulus(BN,SIGN,LEN,NN),
    S = s_int_const{NN,SIGN,LEN}.

predicate const_fold_binop(in scalar_binop, in LN:int, in RN:int, out N:int).

const_fold_binop(sb_plus,    LN,RN,N) :- int_add(LN,RN,N).
const_fold_binop(sb_and,     LN,RN,N) :- int_ge(LN,0), int_ge(RN,0), int_band(LN,RN,N).
const_fold_binop(sb_xor,     LN,RN,N) :- int_ge(LN,0), int_ge(RN,0), int_bxor(LN,RN,N).
const_fold_binop(sb_or,      LN,RN,N) :- int_ge(LN,0), int_ge(RN,0), int_bor(LN,RN,N).
const_fold_binop(sb_mul,     LN,RN,N) :- int_mul(LN,RN,N).
const_fold_binop(sb_minus,   LN,RN,N) :- int_sub(LN,RN,N).
const_fold_binop(sb_div,     LN,RN,N) :- int_div(LN,RN,N).
const_fold_binop(sb_mod,     LN,RN,N) :- int_mod(LN,RN,N).
const_fold_binop(sb_shiftlt, LN,RN,N) :- int_exp(2,RN,EXP), int_mul(LN,EXP,N).
const_fold_binop(sb_shiftrt, LN,RN,N) :- int_exp(2,RN,EXP), int_div(LN,EXP,N).

% const-fold binary operations. TODO: should check for mismatched scalar kinds
try_simplify_scalar(s_binop{OP,LS,RS},S) :-
    LS = s_int_const{LN,SIGN,LEN},
    RS = s_int_const{RN,_,_},
    const_fold_binop(OP,LN,RN,BN),
    signed_modulus(BN,SIGN,LEN,NN),
    S = s_int_const{NN,SIGN,LEN}.

% arithmetic axiom: 0+x == x
try_simplify_scalar(s_binop{sb_plus, LS, RS}, RS) :-
    LS = s_int_const{0,_,_}, RS \= s_int_const{_,_,_}.
try_simplify_scalar(s_binop{sb_plus, LS, RS}, LS) :-
    RS = s_int_const{0,_,_}, LS \= s_int_const{_,_,_}.

% arithmetic axiom: x-x == 0
try_simplify_scalar(s_binop{sb_minus,LS,LS},ZS) :-
    scalar_kind(LS,sk_int{SIGN,LEN}),
    ZS = s_int_const{0,SIGN,LEN}.

% arithmetic axiom: x+(-y) == x-y
try_simplify_scalar(s_binop{sb_plus,LS,s_unop{su_neg,RS}},S) :-
    (LS \= s_int_const{_,_,_}; RS \= s_int_const{_,_,_}),
    S = s_binop{sb_minus,LS,RS}.
try_simplify_scalar(s_binop{sb_plus,s_unop{su_neg,LS},RS},S) :-
    (LS \= s_int_const{_,_,_}; RS \= s_int_const{_,_,_}),
    S = s_binop{sb_minus,RS,LS}.

predicate commutative_binop(out scalar_binop).
commutative_binop(sb_plus) :- .
commutative_binop(sb_and) :- .
commutative_binop(sb_xor) :- .
commutative_binop(sb_or) :- .
commutative_binop(sb_mul) :- .

% canonicalize commutative binary operations
try_simplify_scalar(s_binop{OP, LS, RS}, s_binop{OP, RS, LS}) :-
    (LS \= s_int_const{_,_,_}; RS \= s_int_const{_,_,_}),
    commutative_binop(OP),
    lessthan(RS, LS).

predicate const_fold_cmp(in t_scalar_cmp, in LN:int, in RN:int).

const_fold_cmp(sc_eq, LN,RN) :- int_eq(LN,RN).
const_fold_cmp(sc_ne, LN,RN) :- int_ne(LN,RN).
const_fold_cmp(sc_lt, LN,RN) :- int_lt(LN,RN).
const_fold_cmp(sc_le, LN,RN) :- int_le(LN,RN).
const_fold_cmp(sc_gt, LN,RN) :- int_gt(LN,RN).
const_fold_cmp(sc_ge, LN,RN) :- int_ge(LN,RN).

% const-fold comparisons
try_simplify_scalar_cmp(sc{OP, LS, RS}, G) :-
    LS = s_int_const{LN,SIGN,LEN},
    RS = s_int_const{RN,SIGN,LEN},
    (const_fold_cmp(OP,LN,RN), #bool_g(true,G);
     ~const_fold_cmp(OP,LN,RN), #bool_g(false,G)).
try_simplify_scalar_cmp(sc_eqz{S}, G) :-
    S = s_int_const{N,_,_},
    (int_eq(N,0), #bool_g(true,G);
     int_ne(N,0), #bool_g(false,G)).

try_simplify_scalar_cmp(sc{sc_eq, LS, RS}, G) :-
    (LS = s_int_const{0,_,_}, NS = RS;
     RS = s_int_const{0,_,_}, NS = LS),
    NS \= s_int_const{_,_,_},
    #id_g(br_cmp{sc_eqz{NS}}, G).
try_simplify_scalar_cmp(sc{sc_ne, LS, RS}, G) :-
    (LS = s_int_const{0,_,_}, NS = RS;
     RS = s_int_const{0,_,_}, NS = LS),
    NS \= s_int_const{_,_,_},
    #id_g(br_cmp{sc_eqz{NS}}, NG), #not(NG, G).

% simplify comparisons on a guarded scalar set if only one guard is possible.
% this effectively reverses the guard->scalar coercion performed when storing
% a boolean value in an integer
try_simplify_scalar_cmp(sc_eqz{s_guard{GS}}, G) :-
    ~(map_search(GS, XS, _), XS \= s_int_const{_,_,_}),
    \/map_search(GS, s_int_const{0,_,_}, XG):list_all(XG,[G]).

% -----------------------------------------------------------------------------
% Set of scalars/vectors/traces used by an integer expression

    % Base cases
scalar_used(S, su_scalar{S}) :- .
bit_used(B, su_bit{B}) :- .

    % Scalar propagation
scalar_used(s_cast{IS, _}, V) :- scalar_used(IS, V).
scalar_used(s_guard{GMAP}, V) :-
    map_search(GMAP, S, G), (scalar_used(S, V); guard_used(G, V)).
scalar_used(s_unop{_, IS}, V) :- scalar_used(IS, V).
scalar_used(s_binop{_, LS, RS}, V) :- (scalar_used(LS, V); scalar_used(RS, V)).

    % Bit propagation
bit_used(br_cmp{sc{_, LS, RS}}, V) :- (scalar_used(LS, V); scalar_used(RS, V)).
bit_used(br_cmp{sc_eqz{S}}, V) :- scalar_used(S, V).
bit_used(br_ioverflow{S}, V) :- scalar_used(S, V).

    % Generate usage for guards/traces
guard_used(G, V) :-
    #g_id(G, B), bit_used(B, V).
trace_used(T, V) :-
    trace_sub(T, index{_,LI}, _), list_mem(LI, i_offset{_,I}),
    trace_nrep(I, S), scalar_used(S, V).

    % Generate usage of particular traces
scalar_trace_used(S,T) :- scalar_used(S,su_scalar{s_unconstrained{vr_t{T},_}}).
scalar_trace_used(S,T) :- scalar_used(S,su_scalar{s_unconstrained{vr_st{T,_,_},_}}).
bit_trace_used(B,T) :- bit_used(B,su_scalar{s_unconstrained{vr_t{T},_}}).
bit_trace_used(B,T) :- bit_used(B,su_scalar{s_unconstrained{vr_st{T,_,_},_}}).
guard_trace_used(G,T) :- guard_used(G,su_scalar{s_unconstrained{vr_t{T},_}}).
guard_trace_used(G,T) :- guard_used(G,su_scalar{s_unconstrained{vr_st{T,_,_},_}}).
trace_trace_used(BT,T) :- trace_used(BT,su_scalar{s_unconstrained{vr_t{T},_}}).
trace_trace_used(BT,T) :- trace_used(BT,su_scalar{s_unconstrained{vr_st{T,_,_},_}}).

% -----------------------------------------------------------------------------
% Generic guard/scalar mapping

map_guard(X,RG,NG) :- try_map_guard(X,RG,NG,no).
map_scalar(X,RS,NS) :- try_map_scalar(X,RS,NS,no).
map_bit(X,RB,NG) :- try_map_bit(X,RB,NG,no).

map_guard(X,RG,NNG) :- try_map_guard(X,RG,NG,yes{XX}), map_guard(XX,NG,NNG).
map_scalar(X,RS,NNS) :- try_map_scalar(X,RS,NS,yes{XX}), map_scalar(XX,NS,NNS).
map_bit(X,RB,NNG) :- try_map_bit(X,RB,NG,yes{XX}), map_guard(XX,NG,NNG).

map_guard(X,RG,RG) :- ~try_map_guard(X,RG,_,_),
    #bool_g(_,RG).

map_guard(X,RG,NG) :- ~try_map_guard(X,RG,_,_),
    #and(RG0,RG1,RG),
    map_guard(X,RG0,NG0),
    map_guard(X,RG1,NG1),
    #and(NG0,NG1,NG).

map_guard(X,RG,NG) :- ~try_map_guard(X,RG,_,_),
    #or(RG0,RG1,RG),
    map_guard(X,RG0,NG0),
    map_guard(X,RG1,NG1),
    #or(NG0,NG1,NG).

map_guard(X,RG,NG) :- ~try_map_guard(X,RG,_,_),
    #not(RG0,RG),
    map_guard(X,RG0,NG0),
    #not(NG0,NG).

map_guard(X,RG,NG) :- ~try_map_guard(X,RG,_,_),
    #id_g(B,RG), map_bit(X,B,NG).

map_bit(X,RB,NG) :- ~try_map_bit(X,RB,_,_),
    RB=br_cmp{sc{OP,RS0,RS1}},
    map_scalar(X,RS0,NS0),
    map_scalar(X,RS1,NS1),
    simplify_scalar_cmp(sc{OP,NS0,NS1},NG).

map_bit(X,RB,NG) :- ~try_map_bit(X,RB,_,_),
    RB=br_cmp{sc_eqz{RS0}},
    map_scalar(X,RS0,NS0),
    simplify_scalar_cmp(sc_eqz{NS0},NG).

map_bit(X,RB,NG) :- ~try_map_bit(X,RB,_,_),
    RB=br_ioverflow{RS0},
    map_scalar(X,RS0,NS0),
    #id_g(br_ioverflow{NS0},NG).

map_bit(X,RB,NG) :- ~try_map_bit(X,RB,_,_),
    RB=br_abit{AR},
    AR \= ar_extra{_},  % do not implement for abstract bits
    #id_g(br_abit{AR},NG).

map_scalar(X,RS,RS) :- ~try_map_scalar(X,RS,_,_),
    (RS=s_int_const{_,_,_};
     RS=s_float_const{_,_}).

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_unconstrained{vr_t{RT},K},
    map_trace(X,RT,NT),
    NS=s_unconstrained{vr_t{NT},K}.

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_unconstrained{vr_st{RT,P,E},K},
    map_trace(X,RT,NT),
    NS=s_unconstrained{vr_st{NT,P,E},K}.

map_scalar(X,RS,RS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_unconstrained{V,_},
    V\=vr_t{_}, V\=vr_st{_,_,_}.

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_cast{RS0,K},
    map_scalar(X,RS0,NS0),
    simplify_scalar(s_cast{NS0,K},NS).

predicate map_gslist(in ts_map,
                     in list[t_pair[scalar,g_guard]],
                     out list[t_pair[scalar,g_guard]]).
map_gslist(_,[],[]) :- .
map_gslist(X,[pair{RS,RG}|RTAIL],[pair{NS,NG}|NTAIL]) :-
    map_scalar(X,RS,NS),
    map_guard(X,RG,NG),
    map_gslist(X,RTAIL,NTAIL).

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_guard{RGS}, map_to_sorted_list(RGS,RSLIST),
    map_gslist(X,RSLIST,NSLIST),
    map_of_list(NSLIST,NGS), NS=s_guard{NGS}.

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_unop{OP,RS0},
    map_scalar(X,RS0,NS0),
    simplify_scalar(s_unop{OP,NS0},NS).

map_scalar(X,RS,NS) :- ~try_map_scalar(X,RS,_,_),
    RS=s_binop{OP,RS0,RS1},
    map_scalar(X,RS0,NS0),
    map_scalar(X,RS1,NS1),
    simplify_scalar(s_binop{OP,NS0,NS1},NS).

map_trace(_,root{R},root{R}) :- .
map_trace(_,empty,empty) :- .
map_trace(X,drf{RT},drf{NT}) :- map_trace(X,RT,NT).
map_trace(X,fld{RT,F,C},fld{NT,F,C}) :- map_trace(X,RT,NT).
map_trace(X,rfld{RT,F,C},rfld{NT,F,C}) :- map_trace(X,RT,NT).

map_trace(X,index{RT,[]},index{NT,[]}) :- map_trace(X,RT,NT).
map_trace(X,index{RT,[RI|RIT]},index{NT,[NI|NIT]}) :-
    map_trace(X,index{RT,RIT},index{NT,NIT}),
    (RI=i_offset{Y,RV}, trace_nrep(RV,RS), map_scalar(X,RS,NS),
         (NS=s_unconstrained{vr_t{XNT},_}, NI=i_offset{Y,trace{XNT}};
          NS\=s_unconstrained{vr_t{_},_}, NI=i_offset{Y,nrep{NS}});
     RI\=i_offset{_,_}, NI=RI).

% -----------------------------------------------------------------------------
% Builtin mappings

% replace a trace everywhere it occurs. reapply the mapping to the result
% so that we capture any inner indexes on pieces of the trace
try_map_scalar(ts_reptrace{RT,NT},RS,NS,yes{ts_reptrace{RT,NT}}) :-
    RS=s_unconstrained{vr_t{RBT},Kind},
    RT\=NT, trace_sub(RBT,RT,XT), trace_compose(s_func,NT,XT,NBT),
    NS=s_unconstrained{vr_t{NBT},Kind}.
try_map_scalar(ts_reptrace{RT,NT},RS,NS,yes{ts_reptrace{RT,NT}}) :-
    RS=s_unconstrained{vr_st{RBT,P,E},Kind},
    RT\=NT, trace_sub(RBT,RT,XT), trace_compose(s_func,NT,XT,NBT),
    NS=s_unconstrained{vr_st{NBT,P,E},Kind}.

% replace a scalar outright
+try_map_scalar(ts_repscalar{RS,NS},RS,NS,no).

% replace a set of vectors/bits
try_map_scalar(ts_vbreplace{VMAP,_},s_unconstrained{V,K},S,no) :-
    map_search(VMAP,pair{V,K},S).
try_map_bit(ts_vbreplace{_,BMAP},br_abit{B},G,no) :-
    map_search(BMAP,B,G).

% -----------------------------------------------------------------------------

predicate guarded_scalar_kind(in list[guarded_scalar], in t_scalar_kind).

scalar_kind(s_int_const{_, Signed, Bits}, sk_int{Signed, Bits}) :- .
scalar_kind(s_float_const{_, Bits},       sk_float{Bits}) :- .
scalar_kind(s_unconstrained{_, Kind},     Kind) :- .
scalar_kind(s_cast{_, Kind},              Kind) :- .

?scalar_kind(s_guard{M}, _),
    map_empty(M),
    +warning("Empty guarded expression passed to scalar_kind").

scalar_kind(s_guard{M}, Kind) :-
    map_to_sorted_list(M, [pair{S, _G}|Gs]),
    scalar_kind(S, Kind),
    guarded_scalar_kind(Gs, Kind).

scalar_kind(s_unop{_, S}, Kind) :-
    scalar_kind(S, Kind).

scalar_kind(s_binop{_, S1, _S2}, K1) :-
    scalar_kind(S1, K1).

    % Check for a type mismatch in the arguments to a binary operator.
    % Left and right shifts can have different operand and operator types.
?scalar_kind(s_binop{Op, S1, S2}, _),
    scalar_kind(S1, K1),
    scalar_kind(S2, K2),
    K1 \= K2,
    Op \= sb_shiftlt,
    Op \= sb_shiftrt,
    +warning("Mismatched kinds of scalar in arguments to binary operation",
        K1, K2).

guarded_scalar_kind([], K) :- .
guarded_scalar_kind([pair{S, G}|GSs], K) :- 
    guarded_scalar_kind(GSs, K).
?guarded_scalar_kind([pair{S, _G}|_], K),
    scalar_kind(S, SK),
    K \= SK,
    +warning("Mismatched kinds of scalar in guarded scalar expression",
        K, S, SK).
    
% -----------------------------------------------------------------------------
% Stringification

    % maybe_bracket(PrecContext, PrecTopOp, Str, MaybeBracketedStr)
    % Add brackets to a string if the top-level operator's precedence is lower
    % than a given context precedence.
predicate maybe_bracket(in int, in int, in string, out string) succeeds [once].
maybe_bracket(PC, P, S0, "(" ^ S0 ^ ")") :- int_lt(P, PC).
maybe_bracket(PC, P, S0, S0)             :- int_ge(P, PC).

    % Convert a guard/scalar/scalar comparison to a string, given the 
    % precendence context in which the string is to appear.
predicate guard_string_x(in g_guard, in int, out string) succeeds [once].
predicate scalar_cmp_string_x(in scalar_cmp, in int, out string)
    succeeds [once].
predicate scalar_string_x(in scalar, in int, out string) succeeds [once].
predicate arep_string_x(in g_arep, in int, out string) succeeds [once].

guard_string_x(G, _, BS) :- #bool_g(B, G), tostring(B, BS).
guard_string_x(G, PC, BS) :- #id_g(B, G), 
    (
        B = br_cmp{SC},
        scalar_cmp_string_x(SC, PC, BS)
    ;
        B = br_ioverflow{S},
        scalar_string_x(S, PC, SS),
        BS = "overflow(" ^ SS ^ ")"
    ;
        B = br_abit{AR},
        arep_string_x(AR, PC, BS)
    ).
guard_string_x(G, PC, S) :- 
    (
        #or(G1, G2, G), P = 0, Sep = "||"
    ;
        #and(G1, G2, G), P = 1, Sep = "&&"
    ),
    guard_string_x(G1, P, S1), guard_string_x(G2, P, S2),
    SB = S1 ^ " " ^ Sep ^ " " ^ S2, maybe_bracket(PC, P, SB, S).

guard_string_x(G, PC, S) :- 
    P = 10,
    #not(G1, G),
    (
        #id_g(br_cmp{sc_eqz{LS}}, G1), scalar_string_x(LS, P, SB)
    ;
        ~#id_g(br_cmp{sc_eqz{_}}, G1), guard_string_x(G1, P, S1),
        SB = "!" ^ S1
    ),
    maybe_bracket(PC, P, SB, S).

scalar_cmp_string_x(sc_eqz{LS}, PC, S) :-
    P = 10, scalar_string_x(LS, P, LSS), 
    SB = "!" ^ LSS, maybe_bracket(PC, P, SB, S).

scalar_cmp_string_x(sc{Op, LS, RS}, PC, S) :-
    scalar_cmp_op(Op, OpS, P),
    scalar_string_x(LS, P, LSS), scalar_string_x(RS, P, RSS),
    SB = LSS ^ " " ^ OpS ^ " " ^ RSS, maybe_bracket(PC, P, SB, S).

scalar_string_x(s_int_const{N,_,_},_,SS) :- tostring(N,SS).
scalar_string_x(s_float_const{N,_},_,SS) :- tostring(N,SS).

scalar_string_x(s_unconstrained{vr_t{T},_},_,SS) :-
    trace_string(T,SS).

scalar_string_x(s_unconstrained{vr_st{T,P,_},_},_,SS) :-
    trace_string(T,TS), tostring(P,PS),
    SS = "soft(" ^ TS ^ "," ^ PS ^ ")".

scalar_string_x(s_unconstrained{vr_i{P,E},_},_,SS) :-
    (exp_string(E,ES); ~exp_string(E,_), ES="???"), tostring(P,PS),
    SS = "uninterpreted(" ^ ES ^ "," ^ PS ^ ")".

scalar_string_x(s_unconstrained{vr_c{SUM,_,T},_},_,SS) :-
    trace_string(T,TS), tostring(SUM,SUMS),
    SS = "clobber(" ^ TS ^ "," ^ SUMS ^ ")".

scalar_string_x(s_unconstrained{vr_instscalar{SUM,_,V},K},P,SS) :-
    scalar_string_x(s_unconstrained{V,K},P,VS), tostring(SUM,SUMS),
    SS = "instscalar(" ^ VS ^ "," ^ SUMS ^ ")".

scalar_string_x(s_cast{RS,sk_int{SIGN,LEN}},P,SS) :-
    scalar_string_x(RS,P,RSS),
    (SIGN=true, SIGNS="int"; SIGN=false, SIGNS="uint"), tostring(LEN,LENS),
    SS = "(" ^ SIGNS ^ LENS ^ ")(" ^ RSS ^ ")".

predicate glist_string(in list[t_pair[scalar,g_guard]], in P:int,
                       out list[string]).
glist_string([],_,[]) :- . 
glist_string([pair{V,G}|TAIL],P,[S|STAIL]) :-
    scalar_string_x(V,P,VS), guard_string_x(G,P,GS),
    S = GS ^ " -> " ^ VS, glist_string(TAIL,P,STAIL).

scalar_string_x(s_guard{GSET},P,SS) :-
    map_to_sorted_list(GSET,GLIST), glist_string(GLIST,P,SLIST),
    SS = "[" ^ str_cat_list_sep(SLIST,",") ^ "]".

scalar_string_x(s_unop{OP,RS},P,SS) :-
    scalar_string_x(RS,P,RSS), sunop(UOP,OP), unop_str(UOP,OPS),
    SS = OPS ^ "(" ^ RSS ^ ")".

scalar_string_x(s_binop{OP,LS,RS},P,SS) :-
    scalar_string_x(LS,P,LSS), scalar_string_x(RS,P,RSS),
    sbinop(BOP,OP), binop_str(BOP,OPS),
    SS = "(" ^ LSS ^ OPS ^ RSS ^ ")".

arep_string_x(ar_path{P0,P1},_,SS) :-
    tostring(P0,P0S), tostring(P1,P1S),
    SS = "path_bit(" ^ P0S ^ "," ^ P1S ^ ")".

arep_string_x(ar_entry{P,S,T},_,SS) :-
    tostring(P,PS), trace_string(S,S0), trace_string(T,S1),
    SS = "entry_bit(" ^ PS ^ "," ^ S0 ^ "," ^ S1 ^ ")".

arep_string_x(ar_exit{SUM,_,S,T},_,SS) :-
    tostring(SUM,SUMS), trace_string(S,S0), trace_string(T,T1),
    SS = "exit_bit(" ^ SUMS ^ "," ^ S0 ^ "," ^ T1 ^ ")".

arep_string_x(ar_clobber{SUM,_,T},_,SS) :-
    tostring(SUM,SUMS), trace_string(T,TS),
    SS = "clobber_bit(" ^ SUMS ^ "," ^ TS ^ ")".

arep_string_x(ar_instguard{SUM,_,AR},PC,SS) :-
    tostring(SUM,SUMS), arep_string_x(AR,PC,PS),
    SS = "instguard_bit(" ^ SUMS ^ "," ^ PS ^ ")".

% NOTE: do not implement arep_string_x for abstract bits here

    % If no precedence is provided, assume an arbitrarily low precedence 
    % context.
guard_string(G, S) :-
    guard_string_x(G, -1, S).
scalar_string(G, S) :-
    scalar_string_x(G, -1, S).
scalar_cmp_string(G, S) :-
    scalar_cmp_string_x(G, -1, S).

dstring_nrep(_, V, STR) :- scalar_string(V, STR).
nrep_string(V, STR) :- scalar_string(V, STR).

% -----------------------------------------------------------------------------

debug_scalar(), ?eval(P, E, _, _), ~eval(P, E, _, _), 
    point_location(P, File, Line),
    exp_string(E, ES),
    +warning("eval failed", P, E, File, Line, ES).

% -----------------------------------------------------------------------------
