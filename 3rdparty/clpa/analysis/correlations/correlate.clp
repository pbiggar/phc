%%
% Authors:
%   Isil Dillig    <isil@stanford.edu>
%   Thomas Dillig  <tdillig@stanford.edu>
%
% Copyright (c) 2006,
%   The Board of Trustees of The Leland Stanford Junior University
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice,
% this list of conditions and the following disclaimer.
% 
% 2. Redistributions in binary form must reproduce the above copyright notice,
% this list of conditions and the following disclaimer in the documentation
% and/or other materials provided with the distribution.
% 
% 3. The names of the contributors may not be used to endorse or promote
% products derived from this software without specific prior written
% permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.
%%

import "../memory/scalar_sat.clp".
%import "../base/cfgdot.clp".
import "../base/utility.clp".
import "./scalar-helpers.clp".


%-----------------------------------------------
% FUNCTIONALITY:
% ---------------
% The predicate "necessary_cond" determines an externally visible necessary (and possibly much simpler)
% condition for a given guard.
%
%
%
% The predicate "sufficient_cond" determines an externally visible sufficient condition for a given guard.
%
%
% Potential usage for these predicates: 
% Many programmers pass flags to ensure that a certain event does or does not happen in a called function.
% For example, if a flag is false, a pointer is never dereferenced or a variable is uninitialized etc. 
% These publicly exported predicates can be useful for determining these kinds of correlations between "events"
% of interest and arguments of a function. In other words, they can allow for path-sensitive function summaries that 
% do not contain unwanted noise, in the form of (potentially very long) irrelevant conditions.
% 
% ----------------------------------------

% Publicly exported predicates

% Guard G is a necessary condition for guard SG.
predicate necessary_cond(in SG:g_guard, in SUM:sum, G:g_guard).

% Guard G is a sufficient condition for guard SG.
predicate sufficient_cond(in SG:g_guard, in SUM:sum, G:g_guard).


% If PG is a sufficient condition propagated from a called function,
% propagate that condition. If the condition involves locations not
% visible outside this calling context (or non-deterministic conditions),
% return false as a sufficient condition. NPG is the new condition
% that should be included in the summary. 
predicate propagate_sufficient_cond(in PG: g_guard, in SUM:sum, out NPG: g_guard).

% If PG is a necessary condition propagated from a called function,
% propagate that condition.If the condition involves locations not
% visible outside this calling context (or non-deterministic conditions),
% return true as a necessary condition. NPG is the new condition
% that should be included in the summary. 
predicate propagate_necessary_cond(in PG: g_guard, in SUM:sum, out NPG: g_guard).

% ----------------------------------------------------------------------
% Predicates used by the topdown-correlation analysis that we need.

% Session associated with function F.
session td_corr(F:string).

% The relevant return condition of this function.
predicate ret_cond(G:g_guard).

% ----------------------------------------------------------------------
% Predicates generated by the correlation analysis going bottom up

% Session associated with function F.
session bu_corr(F:string).

% The exact return value(s) of this function, for inlining within any caller
predicate ret_val(V:t_trace_val,G:g_guard).

% -------------------------------------------------------------------
% Find all relevant predicates. 
% "Relevant" predicates are all of the predicates inside if statements
% and those discovered at the calling context by the topdown-correlation
% analysis.

% G is an atomic predicate inside an if statement
% in this function.
predicate pred(G:g_guard).

% All guards inside branches should be marked as pred.
branch(P, _, _, _), branch_take(P, _, G), sum_body(SUM, P), guard_visible(SUM, G), +pred(G).

% -----------------------------------------------------------

% CallSiteGuard: a condition involving a function return value 
% used at a call site of this function.
% ReturnGuard is the guard under which the CallSiteGuard will hold
% within this function.
% Example: Consider the Call site guard return < 0,
% then, the ReturnGuard will be the guard under which return < 0
% will hold, for example, malloc()=NULL.
%
% ReturnGuard is a sufficient condition for the CallSiteGuard.

predicate return_pred(CallSiteGuard:g_guard, ReturnGuard: g_guard ).

predicate unify_return_pred(CallSiteGuardG: g_guard, ReturnGuard: g_guard).


% The expression IE is returned under guard G.
predicate return_exp(IE: scalar, G:g_guard).

cil_stmt_return(S), cil_stmt_return_exp(S,E), exp_point(E, P),
	evals(P, E, IE), guard(P, G), +return_exp(IE, G).

% For those return conditions discovered by the topdown analysis, 
% find the guard under which the comparison will hold.
% For example, if return == -1 is a predicate discovered by the
% topdown analysis and malloc()==NULL is the guard for this return
% statement, remember the relationship between the two guards
% using the return_pred predicate.

% NOTE: This is not the return guard itself, because there may be multiple 
% conditions in the function which imply the return condition. We must
% take the disjunction of all of these conditions to get the guard in this function
% that will guarantee a class of return values to be returned, and vice verca.
% Note that this has to be an equivalence relation for soundness.
cil_curfn(F), td_corr(F)->ret_cond(G), %+print("COLLECTED GUARD FROM TOP_DOWN: ", F, G),
	return_exp(IE, RG), 
	replace_exp_guard(G, IE, NewG), 
	#not(NewG, NotNewG), ~guard_sat(NotNewG), %NewG is a taultology
	+unify_return_pred(G, RG).
	%{#not(G, NG), %in case, the negation is not checked at call site, we also add the negation.
	#not(RG, NRG),
	+unify_return_pred(NG, NRG).%}

	
% Or all the guards that imply the predicate at the call site.
unify_return_pred(G, _), \/unify_return_pred(G, URG):#or_all(URG, RG), 
	+return_pred(G, RG), 
	#not(RG, NRG), #not(G, NG),
        +print("Return pred: ", NRG),
	+return_pred(NG, NRG).

% -----------------------------------------------------------------

% V is a local trace or unconstrained internal data to SUM
predicate guard_local_vector(in SUM:sum, in V:g_vecrep).

% for direct accesses to non-soft traces, make sure the trace is visible
guard_local_vector(SUM,vr_t{T}) :- ~trace_alloc(SUM,T,ak_external).

% pretty much every other type of vector is bad
+guard_local_vector(_,vr_st{_,_,_}).
+guard_local_vector(_,vr_i{_,_}).
+guard_local_vector(_,vr_c{_,_,_}).
+guard_local_vector(_,vr_instscalar{_,_,_}).
+guard_local_vector(_,vr_buffersize{_}).
+guard_local_vector(_,vr_u{_}).

% intermediate recursive and offset traces
guard_local_vector(SUM,vr_t{T}) :- trace_sub(T,index{_,I},_),
    list_mem(I,i_chain{_,_,_}).
guard_local_vector(SUM,vr_t{T}) :- trace_sub(T,index{_,I},_),
    list_mem(I,i_offset{_,IV}),
    trace_nrep(IV,IS), scalar_used(IS,su_scalar{s_unconstrained{V,_}}),
    guard_local_vector(SUM,V).

% Guard G is visible if it contains no local vectors
predicate guard_visible(in SUM:sum, in G:g_guard).
guard_visible(SUM,G) :-
    ~(guard_used(G,su_scalar{s_unconstrained{V,_}}), guard_local_vector(SUM,V)),
    ~#g_id(G,br_abit{_}).

% -----------------------------------------------------------------

% Inlining function return values within callers.
% We normally have to discard the return values of callees when they
% find their way into branches - no way to represent the return value
% within the caller. For callees which simply return a particular fixed
% value, we want to inline that return value both for extra precision
% and also so that we can establish correlations for branches based
% on that return value

predicate local_value(in SUM:sum,in V:t_trace_val).
local_value(SUM,trace{T}) :- ~trace_alloc(SUM,T,ak_external).
local_value(SUM,nrep{S}) :-
        scalar_used(S,su_scalar{s_unconstrained{V,_}}),
        guard_local_vector(SUM,V).

% infer the possible return values
predicate return_value(V:t_trace_val,G:g_guard).
access(P,root{return},write), ~trace_type(s_func,root{return},y_comp{_}),
        guard(P,G0), iset(P,_,I), cil_instr_set(I,_,E), eval(P,E,V,G1),
        #and(G0,G1,G), +return_value(V,G).

% add the possible return values to the summary, provided that they can
% all be exactly expressed without using any local data
cil_curfn(F), return_value(_,_),
        ~(return_value(XV,_), local_value(s_func,XV)),
        ~(return_value(_,XG), ~guard_visible(s_func,XG)),
        return_value(V,G), +bu_corr(F)->ret_val(V,G).

% consume return-value relationships and clobber the caller's return value,
% replacing it with the precise value
dircall(I,F), bu_corr(F)->ret_val(CV,CG), icall(P,_,I), callret(I,RV),
        +no_exit_aliasing(s_call{I},P),
        #bool_g(false,FG), +inst_transfer_necessary(s_call{I},P,root{RV},FG),
        inst_trace_val(s_call{I},P,CV,V,G0), inst_guard(s_call{I},P,CG,G1),
        #and(G0,G1,G), +inst_transfer(P,root{RV},V,G).

% -----------------------------------------------------------------
predicate unify_necessary_cond(SG:g_guard, SUM: sum, G:g_guard).
predicate unify_sufficient_cond(SG:g_guard, SUM: sum, G:g_guard).

% G is true/false
predicate bool_cond(G:g_guard).

% Base cases
necessary_cond(SG, SUM, TRUE) :- #not(SG, NSG), ~guard_sat(NSG), 
	#bool_g(true, TRUE), +bool_cond(SG).

sufficient_cond(SG, SUM, FALSE) :- ~guard_sat(SG), 
	#bool_g(false, FALSE), +bool_cond(SG).


necessary_cond(SG, SUM, FALSE) :-  ~guard_sat(SG), 
	#bool_g(false, FALSE), +bool_cond(SG).

sufficient_cond(SG, SUM, TRUE) :-  #not(SG, NSG), ~guard_sat(NSG), 
	#bool_g(true, TRUE), +bool_cond(SG).

% Not true or false, but a necessary or sufficient condition could not be determined
% In this case, need to be conservative; so we have false for sufficient condition
% and true for necessary condition.

necessary_cond(SG, SUM, TRUE) :- ~bool_cond(SG),
	 ~unify_necessary_cond(SG, SUM, _), #bool_g(true, TRUE).
sufficient_cond(SG, SUM, FALSE) :- ~bool_cond(SG), 
	~unify_sufficient_cond(SG, SUM, _), #bool_g(false, FALSE).



% NECESSARY CONDITION
% Case 1: G is a predicate occuring in this function
?necessary_cond(SG, SUM, _), ~bool_cond(SG), pred(G),
	%guard_visible(SUM, G),
        #not(G, NG),  #and(SG, NG, TESTG), ~guard_sat(TESTG), 
 	+unify_necessary_cond(SG, SUM,  G). 

% NECESSARY CONDITION
% Case 2: RG is an "interesting" return value guard that is checked at
% a call site, and G is the guard under which that value is returned.
?necessary_cond(SG, SUM, _), ~bool_cond(SG), return_pred(RG, G),
	#not(G, NG), #and(SG, NG, TESTG), ~guard_sat(TESTG),
	+unify_necessary_cond(SG, SUM, RG).

% SUFFICIENT CONDITION
% Case 1: G is a predicate occuring in this function
?sufficient_cond(SG, SUM, _), ~bool_cond(SG), pred(G),
	%guard_visible(SUM, G),
        #not(SG, NG),  #and(G, NG, TESTG), ~guard_sat(TESTG), 
 	+unify_sufficient_cond(SG, SUM, G). 

% SUFFICIENT CONDITION
% Case 2: RG is an "interesting" return value guard that is checked at
% a call site, and G is the guard under which that value is returned.
?sufficient_cond(SG, SUM, _),  
	~bool_cond(SG), return_pred(RG, G),
	#not(SG, NG),#and(G, NG, TESTG), ~guard_sat(TESTG), 
	+unify_sufficient_cond(SG, SUM, RG).

% throw out redundant necessary conditions: either equivalent or
% implied by another necessary condition
predicate omit_necessary_cond(in SG:g_guard, in SUM: sum, in G:g_guard).
unify_necessary_cond(SG, SUM, G0), unify_necessary_cond(SG, SUM, G1), lessthan(G0,G1),
        (guard_equivalent(G0,G1), OMIT=G1;
         ~guard_equivalent(G0,G1), guard_implies(G0,G1), OMIT=G1;
         ~guard_equivalent(G0,G1), guard_implies(G1,G0), OMIT=G0),
        +omit_necessary_cond(SG, SUM, OMIT).

unify_necessary_cond(SG, SUM, _),
       \/(unify_necessary_cond(SG, SUM, G), ~omit_necessary_cond(SG, SUM, G)):#and_all(G, RG),
       #simplify(RG, SRG), 
       +necessary_cond(SG, SUM, SRG).

% throw out redundant sufficient conditions: either equivalent or
% implying another sufficient condition
predicate omit_sufficient_cond(in SG:g_guard, in SUM: sum, in G:g_guard).
unify_sufficient_cond(SG, SUM, G0), unify_sufficient_cond(SG, SUM, G1), lessthan(G0,G1),
        (guard_equivalent(G0,G1), OMIT=G1;
         ~guard_equivalent(G0,G1), guard_implies(G0,G1), OMIT=G0;
         ~guard_equivalent(G0,G1), guard_implies(G1,G0), OMIT=G1),
        +omit_sufficient_cond(SG, SUM, OMIT).

unify_sufficient_cond(SG, SUM,  _),
       \/(unify_sufficient_cond(SG, SUM, G), ~omit_sufficient_cond(SG, SUM, G)):#or_all(G, RG),
       #simplify(RG, SRG), 
       +sufficient_cond(SG, SUM, SRG).

% -----------------------------------------------------------------
% Sufficient Condition Propagation

predicate precise_sc(G: g_guard).


% The guard is visible at the call site, so
% we can just propagate it.
propagate_sufficient_cond(InG, Sum, InG) :-
	guard_visible(Sum, InG),
	+precise_sc(InG).


% The guard is not visible, i.e it involves the
% return value of the called function. 
% We check if the return value of this
% function implies the sufficient condition
% of the called function. In this case,
% if we can show at the call site that the
% return value cond for this function
% holds, then so does the ret val of the callee.
% This case is important for wrapper functions.
% See regressions in uninit07 to understand 
% what this is doing.
propagate_sufficient_cond(InG, Sum, CallSiteG) :-
	~guard_visible(Sum, InG),
	return_pred(CallSiteG, ReturnG), 
	#not(InG, NotInG),
	#and(NotInG, ReturnG, TestG),
	~guard_sat(TestG),
	+precise_sc(InG).
		
% We couldn't find any precise conditions;
% so we just over-approximate it by false.
propagate_sufficient_cond(InG, Sum, OutG) :-
	~precise_sc(InG),
	#bool_g(false, OutG).


%---------------------------------------------
% Necessary Condition Propagation: TO BE TESTED!!!!
	
predicate precise_nc(G:g_guard).

propagate_necessary_cond(InG, Sum, InG) :-
	guard_visible(Sum, InG),
	+precise_nc(InG).

propagate_necessary_cond(InG, Sum, CallSiteG) :-
	~guard_visible(Sum, InG),
	return_pred(CallSiteG, ReturnG), 
	#not(ReturnG, NotReturnG),
	#and(InG, NotReturnG, TestG),
	~guard_sat(TestG),
	+precise_nc(InG).


propagate_necessary_cond(InG, Sum, OutG) :-
	~precise_nc(InG),
	#bool_g(true, OutG).

% --------------------------------------------------------------------------

 
