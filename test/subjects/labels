# All files will be found by recursive descent of directories, and each found
# file will be assigned the default labels. This is then overriden by matching
# each file against each line in this file, in order. The pattern is specified
# as a regex, but ! is used as a regex delimiter, so you can safely use / in
# the patterns. 
#
# Be aware that all files in a directory are specfied use 'dir/.*', not 'dir/*'.
#
# Possible labels:
#	- non-interpretable or interpretable (interpretable means executable). The
#	    default is to run a purity test to check if they are interpretable
#	- long (default) or short
#	- size-neutral (default) or size-dependent
#	- non-includable (default) or includable
#	- no-test_name (don't run with a particular test)
#
# A common pattern would be to override some tests by adding, for example, the
# following to the bottom of the file:
#	.*				non-interpretable
#	codegen/.*	interpretable

bugs/.*									short interpretable
codegen/.*								short interpretable
dynamic/.*								short interpretable
horrible/.*								short interpretable
inline-c/.*								short non-interpretable
invalid/.*								short non-interpretable # These are all invalid after parsing
parsing/.*								short interpretable
php_bugs/.*								short interpretable
unsupported/.*							short non-interpretable

bugs/bug0009.php						size-dependent
bugs/bug0011.php						size-dependent

parsing/include_complex.php		includable
parsing/included_recursive1.php	includable
parsing/included_recursive2.php	includable

# These tests all cause infinite loops
parsing/binops.php					long no-CompiledVsInterpreted
parsing/for.php						non-interpretable # infinite loops
parsing/for_cond_with_comma.php	non-interpretable # infinite loops
codegen/for_varying_cond.php		non-interpretable # infinite loops

parsing/instring.php					non-interpretable # php's parser doesnt like this


#.*										long
#unsupported/.*						short
