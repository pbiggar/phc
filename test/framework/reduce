#!/usr/bin/env php
<?php

require_once ("lib/header.php");

# This attempts to reduce a test case to a minimal test case. For a program of
# N statements, it attempts to reduce it by N/2 statements chunks, then by N/4
# statement chunks, and so on, while the progrmam still fails. 

# Complexity:
#	 There are N - K possible chunks for chunk size K.  The number of iterations
#	 is (N-N/2) + (N-N/4) + ... + (N-1), which is log_2(N) steps of size N (the
#	 second term converges to N, so we discard it). So the complexity is 
#   O (N log N).


# Approach:
#	
# prog = input_file
# N = num_statements (prog)
# for each k = N/2; k > 0; k /=2
#	for each i = 0; i < N -k; i++
#   new_prog = prog.reduce (i, k)
#   out1 = php new_prog
#   out2 = phc new_prog; ./a.out
#   out1 = homogenize out1
#   out2 = homogenize out2
#   if (out1 != out2)
#    prog = new_prog
#    goto start;

require_once ("Console/Getopt.php");

$cg = new Console_Getopt();
list ($opts, $arguments) = $cg->getOpt($cg->readPHPArgv(), "vh", array ("verbose", "help"));
foreach ($opts as $opt) 
{
	if (isset ($options{$opt[0]})) $options{$opt[0]} += 1;
	else $options{$opt[0]} = 1;
}
$opt_verbose = isset ($options{"v"}) ? $options{"v"} : 0;
$opt_help = isset ($options{"h"});

$filename = $arguments[0];


if ($opt_help)
{
	die (<<<EOL
reduce - A program to automatically reduce test cases for phc- phpcompiler.org

Usage: reduce [OPTIONS] filename

Options:
    -h     Print this help message
    -v     Verbose. Can be set more than once. Set once, prints actions; set 
           twice, prints commands executed; set thrice, dumps results of 
           intermediate stages.

EOL
	);
}


# TODO add two levels of verbosity: the first one prints stuff, the second dumps files

list ($program) = run ("cat $filename");
$N = count_statements ($program);
debug (1, "$N statements");

for ($k = (int)($N/2); $k >= 1; $k = (int)($k/2))
{
// RESTART:
	for ($i = 0; $i <= ($N-$k); $i++)
	{
		# Reduce
		debug (1, "Attempting to reduce by $k statements, starting at statement $i");
		$new_program = reduce ($program, $i, $k);
		dump (3, "$filename.reduced_{$i}_$k", $new_program);

		# Run through PHP
		list ($out1, $err, $exit) = run ("php", $new_program);
		if ($err || $exit) // if the reduced case causes a PHP error, ignore.
		{
			debug (1, "Error running through PHP. Skip.");
			continue;
		}
		$out1 = homogenize_all ($out1);
		dump (3, "$filename.out1_{$i}_$k", $out1);

		# Run through phc
		list ($out2, $err2, $exit2) = run ("src/phc -c", $new_program);
		if ($err2 === "" && $out2 === "" && $exit2 === 0)
		{
			list ($out3, $err3, $exit3) = run ("./a.out");
			$out3 = homogenize_all ($out3);
			dump (3, "$filename.out2_{$i}_$k", $out3);
		}

		if (($out1 !== $out3) || $err3 || $exit3 || $out2 || $err2 || $exit2) // success, we've reduced it while keeping the bug in
		{
			if ($program == $new_program)
			{
				// TODO investigate why this is needed
				debug (1, "The two programs are identical. Ending early.");
				break 2;
			}
			$program = $new_program;
			$N = count_statements ($program);
			$k = $N; // the iteration will divide $N by 2
			debug (1, "Success, program reduced to $N statements");
			continue 2; // to RESTART
		}

	}
}

// we're done, it wont reduce any further
debug (1, "Finished. Reduced to $N statements. Result in $filename.reduced");

file_put_contents ("$filename.reduced", $program);


function reduce ($program_string, $i, $k)
{
	list ($out) = run ("src/phc --run plugins/tools/reduce_statements.la --r-option=$i:$k --dump=plugins/tools/reduce_statements.la", $program_string);
	return $out;
}


function count_statements ($program_string)
{
	list ($out) = run ("src/phc --run plugins/tutorials/count_statements_easy.la", $program_string);
	preg_match ("/(\d+) statements found/", $out, $matched) or die ();
	return $matched[1];
}

function run ($command, $stdin = NULL)
{
	debug (2, "Running command: $command");
	$descriptorspec = array(0 => array("pipe", "r"),
									1 => array("pipe", "w"),
									2 => array("pipe", "w"));

	$pipes = array();

	$handle = proc_open($command, $descriptorspec, &$pipes);
	if ($stdin !== NULL)
	{
		fwrite ($pipes[0], $stdin);
	}
	fclose ($pipes[0]);
	
	$out = "";
	$err = "";
	do
	{
		$out .= stream_get_contents ($pipes[1]);
		$err .= stream_get_contents ($pipes[2]);
		$status = proc_get_status ($handle);
	}
	while ($status["running"]);
	$out .= stream_get_contents ($pipes[1]);
	$err .= stream_get_contents ($pipes[2]);
	# contrary to popular opinion, proc_close doesnt return the exit
	# status
	$exit_code = $status["exitcode"];
	proc_close ($handle);
	debug (2, "Command exited with $exit_code and error: '$err'");
	return array ($out, $err, $exit_code);
}

function above_debug_threshold ($level)
{
	global $opt_verbose;
	return ($level <= $opt_verbose);
}

function debug ($level, $message = NULL)
{
	$above = above_debug_threshold ($level);
	if ($message !== NULL && $above)
		print "$level: $message\n";

	return ($above);
}

function dump ($level, $filename, $output)
{
	debug ($level, "Dumping output to $filename");

	$above = above_debug_threshold ($level);
	if ($above)
		file_put_contents($filename, $output);

	return $above;
}

?>
