#!/usr/bin/env php
<?php

require_once ("lib/header.php");

# This attempts to reduce a test case to a minimal test case. For a program of
# N statements, it attempts to reduce it by N/2 statements chunks, then by N/4
# statement chunks, and so on, while the progrmam still fails. 

# Complexity:
#	 There are N - K possible chunks for chunk size K.  The number of iterations
#	 is (N-N/2) + (N-N/4) + ... + (N-1), which is log_2(N) steps of size N (the
#	 second term converges to N, so we discard it). So the complexity is 
#   O (N log N).


# Approach:
#	
# prog = input_file
# N = num_statements (prog)
# for each k = N/2; k > 0; k /=2
#	for each i = 0; i < N -k; i++
#   new_prog = prog.reduce (i, k)
#   out1 = php new_prog
#   out2 = phc new_prog; ./a.out
#   out1 = homogenize out1
#   out2 = homogenize out2
#   if (out1 != out2)
#    prog = new_prog
#    goto start;

$filename = $argv[1];

# TODO add two levels of verbosity: the first one prints stuff, the second dumps files

list ($program) = run ("cat $filename");
$N = count_statements ($program);
print "$N statements\n";

for ($k = (int)($N/2); $k >= 1; $k = (int)($k/2))
{
// RESTART:
	for ($i = 0; $i <= ($N-$k); $i++)
	{
		# Reduce
		$new_program = reduce ($program, $i, $k);
		print "Attempting to reduce by $k statements, starting at statement $i\n";
		file_put_contents ("$filename.reduced_{$i}_$k", $new_program);

		# Run through PHP
		list ($out1, $err, $exit) = run ("php", $new_program);
		if ($err || $exit) // if the reduced case causes a PHP error, ignore.
		{
			print "Error running through PHP. Skip.\n";
			continue;
		}
		$out1 = homogenize_all ($out1);
		file_put_contents ("$filename.out1_{$i}_$k", $new_program);

		# Run through phc
		list ($out2, $err2, $exit2) = run ("src/phc -c", $new_program);
		if ($err2 === "" && $out2 === "" && $exit2 === 0)
		{
			list ($out3, $err3, $exit3) = run ("./a.out");
			$out3 = homogenize_all ($out3);
			file_put_contents ("$filename.out2_{$i}_$k", $new_program);
		}

		if (($out1 !== $out3) || $err3 || $exit3 || $out2 || $err2 || $exit2) // success, we've reduced it while keeping the bug in
		{
			if ($program == $new_program)
			{
				// TODO investigate why this is needed
				print "The two programs are identical. Ending early.\n";
				break 2;
			}
			$program = $new_program;
			$N = count_statements ($program);
			$k = $N; // the iteration will divide $N by 2
			print "Success, program reduced to $N statements\n";
			continue 2; // to RESTART
		}

	}
}

// we're done, it wont reduce any further
print ("Finished. Reduced to $N statements. Result in $filename.reduced\n");

file_put_contents ("$filename.reduced", $program);


function reduce ($program_string, $i, $k)
{
	list ($out) = run ("src/phc --run plugins/tools/reduce_statements.la --r-option=$i:$k --dump=plugins/tools/reduce_statements.la", $program_string);
	return $out;
}


function count_statements ($program_string)
{
	list ($out) = run ("src/phc --run plugins/tutorials/count_statements_easy.la", $program_string);
	preg_match ("/(\d+) statements found/", $out, $matched) or die ();
	return $matched[1];
}


function run ($command, $stdin = NULL)
{
//	print "Running command: $command\n";
	$descriptorspec = array(0 => array("pipe", "r"),
									1 => array("pipe", "w"),
									2 => array("pipe", "w"));

	$pipes = array();

	$handle = proc_open($command, $descriptorspec, &$pipes);
	if ($stdin !== NULL)
	{
		fwrite ($pipes[0], $stdin);
	}
	fclose ($pipes[0]);
	
	$out = "";
	$err = "";
	do
	{
		$out .= stream_get_contents ($pipes[1]);
		$err .= stream_get_contents ($pipes[2]);
		$status = proc_get_status ($handle);
	}
	while ($status["running"]);
	$out .= stream_get_contents ($pipes[1]);
	$err .= stream_get_contents ($pipes[2]);
	# contrary to popular opinion, proc_close doesnt return the exit
	# status
	$exit_code = $status["exitcode"];
	proc_close ($handle);
	return array ($out, $err, $exit_code);
}
?>
