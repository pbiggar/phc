#!/usr/bin/env php
<?php

require_once ("lib/header.php");

# This attempts to reduce a test case to a minimal test case. For a
# program of N statements, it attempts to reduce it by N/2 statements
# chunks, then by N/4 statement chunks, and so on, while the progrmam
# still fails. 

# Complexity:
# TODO Actually, this is wrong, since each term has a larger
# complexity, because of k.
#
# There are N - K possible chunks for chunk size K. The number of
# iterations is (N-N/2) + (N-N/4) + ... + (N-1), which is log_2(N)
# steps of size N (the second term converges to N, so we discard it).
# So the number of iterations is O (N log N).  Each iteration leads to
# a traversal of each statement, giving worst case complexity of O
# (N^2 log N).


# Approach:
#	
# prog = input_file
# N = num_statements (prog)
# for each k = N/2; k > 0; k /=2
#	for each i = 0; i < N -k; i++
#   new_prog = prog.reduce (i, k)
#   php_out = php new_prog
#   phc_out = phc new_prog; ./a.out
#   php_out = homogenize php_out
#   phc_out = homogenize phc_out
#   if (php_out != phc_out)
#    prog = new_prog
#    goto start;

require_once ("Console/Getopt.php");

$cg = new Console_Getopt();
$command_line = join (" ", $cg->readPHPArgv());
$opt_result = $cg->getopt($cg->readPHPArgv(), "vhc:rdDf:i:U");
if (!is_array ($opt_result))
	die ($opt_result->message."\n");

list ($opts, $arguments) = $opt_result;
$opt_verbose = 0;
$opt_help = false;
$opt_command = "";
$opt_file = NULL;
$opt_interpret = false;
$opt_never_upper = false;
foreach ($opts as $opt) 
{
	switch ($opt[0])
	{
		case 'h': $opt_help = true; break;
		case 'v': $opt_verbose += 1; break;
		case 'U': $opt_never_upper = true; break;
		case 'c': $opt_command .= $opt[1]; break;
		case 'r': $opt_command .= "--run plugins/tools/debug_zval.la --xdump=plugins/tools/debug_zval.la"; break;
		case 'd': $opt_command .= "--run plugins/tools/demi_eval.la --r-option=true --xdump=plugins/tools/demi_eval.la"; break;
		case 'D': $opt_command .= "--run plugins/tools/demi_eval.la --r-option=false --xdump=plugins/tools/demi_eval.la"; break;
		case 'f': $opt_file = $opt[1]; break;
		case 'i': $opt_interpret = $opt[1]; break;
	}
}
if ($opt_command === "") 
	$opt_command = "--xdump=AST-to-HIR";

if ($opt_help || count ($arguments) < 1)
{
	die (<<<EOL
reduce - A program to automatically reduce test cases for phc- phpcompiler.org

Usage: reduce [OPTIONS] filename

Options:
    -h     Print this help message
    -v     Verbose. Can be set more than once. Set once, prints actions; set 
           twice, prints commands executed; set thrice, dumps results of 
           intermediate stages.
    -c     Pass as arguments to the first phc. Be sure to include an --xdump command, or nothing will happen.
    -r     Mnemonic: refcount. The equivalent of "-c--run plugins/tools/debug_zval.la -xdump=plugins/tools/debug_zval.la".
    -d     The equivalent of "-c--run plugins/tools/demi_eval.la -xdump=plugins/tools/demi_eval.la --r-option=true".
    -D     The equivalent of "-c--run plugins/tools/demi_eval.la -xdump=plugins/tools/demi_eval.la --r-option=false".
    -f     Use the passed XML file as the the first program, instead of calling phc.
	 -i     Mnemonic: Interpret. Instead of compiling the script, dump it at the specified pass and interpret it.
	 -U     Never 'upper'

Sample commands:
    reduce -v test/subjects/codegen/0001.php
    reduce "-c--run plugins/tools/debug_zval.la -xdump=plugins/tools/debug_zval.la" test/subjects/codegen/0001.php
    reduce -v 0001.uhir.php

EOL
	);
}

$filename = $arguments[0];

# Passing around code:
#   There is a problem that some code cannot be parsed (ie gotos and labels).
#   If we want to reduce code involving control-flow (and we do), then we need
#   to pass around XML, only unparsing it when necessary.


$num_steps = 0;

if ($opt_file)
{
	$xprogram = file_get_contents ($opt_file);
}
else
{
	debug (2, "Getting initial XML input");
	list ($xprogram, $err, $exit) = run ("src/phc $opt_command $filename");
	if ($err || $exit)
		die ("Program failed. Try -v -v for more info\n");
}

$N = count_statements ($xprogram);
$original = $N;
debug (1, "$N statements");

if ($N == 0)
  die ("No statements. Failing. Try -v -v for more info\n");

# confirm that we can find the bug automatically
if (!do_main_step ($xprogram, 0, 0, $filename))
	die ("Cannot find bug. Failing");


for ($k = (int)($N/2); $k >= 1; $k = (int)($k/2))
{
// RESTART:
	for ($i = 0; $i <= ($N-$k); $i += $k)
	{
	   $result = do_main_step ($xprogram, $i, $k, $filename);
		if ($result !== false)
		{
			$xprogram = $result;
			$N = count_statements ($xprogram);
			$k = $N; // the iteration will divide $N by 2
			debug (1, "Success, program reduced to $N statements");
			debug (1, ""); // put a blank line in the debug
			continue 2;
		}
		debug (1, ""); // put a blank line in the debug
	}
}

// we're done, it wont reduce any further
print "Finished. Reduced from $original to $N statements in $num_steps steps. Result in $filename.reduced\n";

$xprogram = add_comment ($xprogram);
$pprogram = convert ($xprogram, 0); // converted to PHP
$uprogram = convert ($xprogram, 1); // uppered
file_put_contents ("$filename.xreduced", $xprogram);
file_put_contents ("$filename.ureduced", $uprogram);
file_put_contents ("$filename.reduced", $pprogram);

function add_comment ($xprogram)
{
	debug (2, "Adding comment");
	global $command_line;
	list ($out) = run ("src/phc --read-xml=plugins/tools/add_comment.la --run plugins/tools/add_comment.la --r-option=\"Reduced with command line '$command_line'\" --xdump=plugins/tools/add_comment.la", $xprogram);
	return $out;
}

function reduce ($xprogram_string, $start, $num)
{
	debug (2, "Reducing");
	list ($out) = run ("src/phc --read-xml=plugins/tools/reduce_statements.la --run plugins/tools/reduce_statements.la"
							 ." --r-option=$start:$num --xdump=plugins/tools/reduce_statements.la",
							 $xprogram_string);
	return $out;
}

function convert ($xprogram_string, $upper)
{
	global $opt_never_upper;
	if ($opt_never_upper) $upper = false;
	debug (2, "Converting to PHP from XML" . ($upper ? " (uppered)" : ""));
	$upper = $upper ? "u" : ""; // TODO: if this is to be uppered, then we cant remove all?
	list ($out) = run ("src/phc --read-xml=ast --{$upper}dump=ast --run=plugins/tools/remove_all.la", $xprogram_string);
	return $out;
}

function count_statements ($xprogram_string)
{
	debug (2, "Counting statements");
	list ($out, $err, $exit) = run ("src/phc --read-xml=plugins/tutorials/count_statements_easy.la --run plugins/tutorials/count_statements_easy.la", $xprogram_string);
	if ($err || $exit != 0)
	  die ("Error reading number of statements\n");
	debug (2, "Output is: $out");
	preg_match ("/(\d+) statements found/", $out, $matched) or die ();
	return $matched[1];
}

function run ($command, $stdin = NULL)
{
	debug (2, "Running command: $command");
	$result = complete_exec ($command, $stdin);

	if ($result == "Timeout")
		debug (2, "Command timed out");

	return $result;
}

function above_debug_threshold ($level)
{
	global $opt_verbose;
	return ($level <= $opt_verbose);
}

function debug ($level, $message)
{
	if (above_debug_threshold ($level))
		print "$level: $message\n";
}

function dump ($filename, $output)
{
	debug (3, "Dumping to $filename");

	if (above_debug_threshold (3))
		file_put_contents($filename, $output);
}

# Reduce and test the program, passed as XML in $xprogram. Reduce it starting
# from the $start'th statement, by $num statements. For debugging, filename is
# the name of the script we're working on.
# Return false if the program couldnt reduce, or couldnt be tested, or the
# reduced program otherwise.
function do_main_step ($xprogram, $start, $num, $filename)
{
	global $num_steps, $opt_interpret;
	$num_steps++;

	# Reduce
	debug (1, "Attempting to reduce by $num statements, starting at statement $start");
	$xnew_program = reduce ($xprogram, $start, $num);
	$pnew_program = convert ($xnew_program, 0); // converted to PHP
	$unew_program = convert ($xnew_program, 1); // uppered
	$id = "{$num}_$start";
	dump ("$filename.xreduced_$id", $xnew_program);
	dump ("$filename.preduced_$id", $pnew_program);
	dump ("$filename.ureduced_$id", $unew_program);

	if ($xprogram == $xnew_program && $num != 0)
	{
		// this would happen if we dont remove any statements
		// if $num == 0, then this is intentional
		debug (1, "The two programs are identical. Skip.");
		return false;
	}

	# Run through PHP
	debug (2, "Getting PHP output");
	list ($php_out, $php_err, $php_exit) = run ("php", $unew_program);
	if ($php_err || $php_exit) // if the reduced case causes a PHP error, ignore.
	{
		debug (1, "Error running through PHP. Skip.");
		return false;
	}
	$php_out = homogenize_all ($php_out);
	dump ("$filename.php_out_$id", $php_out);

	$phc_error = false;
	if ($opt_interpret)
	{
		# Run it through PHP til the specified pass, then run the output through PHP
		debug (2, "Getting PHP output after running through phc");
		list ($phc_out, $phc_err, $phc_exit) = run ("src/phc --read-xml=ast --dump=$opt_interpret", $xnew_program);
		if ($phc_err === "" && $phc_exit === 0)
		{
			list ($my_out, $my_err, $my_exit) = run ("php", $phc_out);
			$my_out = homogenize_all ($my_out);
			dump ("$filename.phci_out_$id", $my_out);
		}
		else $phc_error = true;
	}
	else
	{
		# Compile and run
		debug (2, "Getting compiled phc output");
		list ($phc_out, $phc_err, $phc_exit) = run ("src/phc --read-xml=ast -c", $xnew_program);
		if ($phc_err === "" && $phc_out === "" && $phc_exit === 0)
		{
			list ($my_out, $my_err, $my_exit) = run ("./a.out");
			$my_out = homogenize_all ($my_out);
			dump ("$filename.phc_out_$id", $my_out);
		}
		else $phc_error = true;
	}

	if ($phc_error)
	{
		debug (1, "phc error. Skip.");
		return false;
	}

	if ($php_err === "Timeout" || $my_err === "Timeout")
	{
		debug (1, "Timeouts. Skip.");
		return false;
	}

	if (		($php_err !== $my_err)
			|| ($php_exit !== $my_exit)
			|| ($php_out !== $my_out)) // success, we've reduced it while keeping the bug in
	{
		debug (2, "Success, bug kept in");
		dump ("$filename.xsuccess_$id", $xnew_program);
		dump ("$filename.psuccess_$id", $pnew_program);
		dump ("$filename.usuccess_$id", $unew_program);
		return $xnew_program;
	}

	debug (2, "Bug removed. Skip.");
	return false;
}
?>
