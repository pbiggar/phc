<chapter id="generatedcode">
<title id="generatedcode.title">Overview of the AST classes and transformation API</title>

<section>
<title></title>

<para> This document explains the code for the AST classes, tree visitor API
and tree transformation API. All this code is generated by a tool called
<application>maketea</application>. It does not explain how this code is
derived from the &phc grammar; some of the details of this process are
explained in <xref linkend="maketeatheory" endterm="maketeatheory.title">.

</section>
<section>

<title>The AST classes</title>

<para> There are two main kinds of AST classes: classes that correspond to
non-terminals in the grammar, and classes that correspond to terminals in the
grammar. These two kinds are called <code>AST_xxx</code> and
<code>Token_xxx</code> respectively. Examples are <code>AST_while</code>,
<code>AST_expr</code>, <code>Token_method_name</code> and
<code>Token_int</code>. </para>

<para> The main difference is that terminal classes have one additional field
(and sometimes two). Every token class gets an attribute called
<code>value</code>. The type of this attribute depends on the token; for most
tokens it is <code>String*</code> (this is the default); however, if the
grammar explicitely specifies a type for the value (in angular brackets, for
example <code>REAL&lt;double&gt;</code>), this overrides the default. If the
default value is overridden, the token class gets an additional attribute
<code>source_rep</code>, which corresponds to the value of the token in the
source value. The type of <code>source_rep</code> is always
<code>String*</code>. For example, the real number <code>5E-1</code> might have
<code>value</code> set to the <code>double</code> 0.5, but
<code>source_rep</code> set to <code>&ldquo;5E-1&rdquo;</code>. Similarly, a
string <code>__FILE__</code> might have <code>value</code> set to
<code>/home/joe/myscript.php</code>, but <code>source_rep</code> set to
<code>__FILE__</code>. If the type of the <code>value</code> attribute it set
to be empty, the token class does not get a value but (but it will get a
<code>source_rep</code> field). This is the case for
<code>Token_null&lt;&gt;</code> in the &phc grammar. </para>

<para> In addition, all the tokens classes have a method called
<code>get_value_as_string()</code> and a method <code>get_source_rep</code>
when applicable. This is useful for programs that operate on general
<code>AST_identifier</code> objects (such as <code>Token_method_name</code> or
<code>Token_class_name</code>) or <code>AST_literal</code> (such as
<code>Token_real</code> or <code>Token_int</code>). Note that the value
returned by <code>get_value_as_string()</code> and
<code>get_source_rep()</code> may be different; for example,
<code>get_source_rep()</code> might return <code>0.5E-1</code>, while
<code>get_value_as_string()</code> might return <code>0.5</code>. </para>

<para> All (non-terminal and terminal) then provide the following methods for
deep equality, pattern matching, cloning, calling a tree visitor and calling a
tree transformer. These methods are explained separately in sections below.
</para>

</section>
<section>

<title>Deep Equality</title>

<para> Deep equality is implemented by <code>bool deep_equals(Object*
other)</code>. It takes into account the entire tree structure generated by
<application>maketea</application>, including any fields that are specified in
the code in the grammar (see <xref linkend="mixin">). Thus,
<code>deep_equals</code> also compares line numbers, comments, etc.  </para>

</section>
<section>

<title>Cloning</title>

<para> Cloning is implemented by <code>deep_clone</code>. Cloning makes a
(deep) copy of a tree, so the set of all pointers in the new tree is completely
distinct from the set of pointers in the old tree. The only exception to this
rule is that cloning the <code>WILDCARD</code> objects (see pattern matching,
below) returns the <code>WILDCARD</code> object itself. </para> 

</section>
<section>

<title>Pattern Matching</title>

<para> Pattern matching is implemented by <code>bool match(Object*
pattern)</code>. Pattern matching differs from deep equality in two ways.
First, it does not take into account any fields added by the mixin code; for
example, it does not compare line numbers or comments.  </para>

<para> Second, <code>match</code> supports the use of wildcards.
<application>Maketea</application> generates a special class called
<code>Wildcard</code>. You should never instantiate this class directly; in
<filename>&lt;phc/ast.h&gt;</filename>, you will find the following
declaration: </para> 

<programlisting>
<reserved>extern</reserved> Wildcard* WILDCARD;
</programlisting>

<para> This <code>WILDCARD</code> is the sole instance of
<code>Wildcard</code>. When <code>match</code> encounters a reference to this
object in a pattern, it does two things: it skips that field in the comparison
(so it acts as a &ldquo;don't care&rdquo;), and it replaces the value of the
field in the pattern by the value in the tree. For example, in the body of the
<code>if</code> in </para>

<programlisting>
Token_class_name* name = <reserved>new</reserved> Token_class_name(<reserved>new</reserved> String("SOME_CLASS"));
Token_class_name* pattern = <reserved>new</reserved> Token_class_name(WILDCARD);

<reserved>if</reserved>(name-&gt;match(pattern))
{
   <emphasis>// ...</emphasis>
}
</programlisting>

<para><code>pattern->value</code> will be set to the corresponding value in
<code>name</code>. Tutorials <xref linkend="treetutorial3"
endterm="treetutorial3.title"> and <xref linkend="treetutorial4"
endterm="treetutorial4.title"> include examples of the use of wildcards. </para>

<para> Calling any methods on the <code>WILDCARD</code> object other than
<code>deep_clone</code> will lead to a runtime error. </para>

</section>
<section>

<title> The Tree Visitor API </title>

<figure id="seqdiagramvisitor">
<title>Sequence Diagram for the Visitor API</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/visitor.jpg">
</imageobject>
</mediaobject>
</figure>

<para> Every AST class provides four methods to support the tree visitor API:
<code>void visit(Tree_visitor*)</code>, <code>void
pre_visit(Tree_visitor*)</code>, <code>void
visit_children(Tree_visitor*)</code> and <code>void
post_visit(Tree_visitor*)</code>. The implementation of each of these methods
is very simple. </para>

<para><code>visit</code> simply calls <code>pre_visit</code>,
<code>visit_children</code> and <code>post_visit</code> in order. It could have
been implemented once and for all in the <code>AST_node</code> class (but is
not, for no particular reason). </para>

<para>For a node <code>x0</code>, which inherits from <code>x1</code>, which
inherits from <code>x2</code>, which in turn inherits from <code>x3</code>,
etc., <code>x0::pre_visit</code> calls <code>pre_x3</code>,
<code>pre_x2</code>, <code>pre_x1</code> and <code>pre_x0</code>, in that
order, on the tree visitor object, passing itself as an argument.  If
<code>x0</code> inherits from multiple classes, all of the appropriate visitor
methods will be invoked. However, if <code>x0</code> inherits from both
<code>x1a</code> and <code>x1b</code>, the programmer should not rely on the
relative order of <code>pre_x1a</code> and <code>pre_x1b</code>. </para>

<para><code>x0::visit_children</code> simply calls
<code>children_x0</code>.</para>

<para><code>x0::post_visit</code> will call <code>post_x0</code>,
<code>post_x1</code>, etc. Again, if <code>x0</code> inherits from both
<code>x1a</code> and <code>x1b</code>, the programmer should not rely on the
relative order of <code>post_x1a</code> and <code>post_x1b</code>. The only
guarantee made by <application>maketea</application> is that the order of the
pre-methods will be the exact reverse of the order of the post-methods. </para>

</section>
<section>

<title>The Tree Transform API </title>

<figure id="seqdiagramtransform">
<title>Sequence Diagram for the Transform API</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/transform.jpg">
</imageobject>
</mediaobject>
</figure>

<para> Every AST class <code>AST_foo</code>, which inherits from
<code>AST_gen_foo</code> provides four methods to support the tree visitor API:
<code>AST_gen_foo* transform(Tree_transformer*)</code>, <code>AST_gen_foo*
pre_transform(Tree_transformer*)</code>, <code>void
transform_children(Tree_transformer*)</code> and <code>AST_gen_foo*
post_transform(Tree_transformer*)</code>. It is not entirely as straightforward
as this; if <code>AST_foo</code> inherits from more than one class, the return
type would probably be <code>AST_foo</code>; in some cases,
<code>transform</code> might return a <code>AST_foo_list</code> instead. See
the section <xref linkend="contextresolution" endterm="contextresolution.title"> in
the grammar formalism for details; here we consider the programmer's
perspective only. The exact signatures for a particular class can always be
found in <filename>ast.h</filename>. </para>

<para> As with the tree visitor API, <code>transform</code> calls
<code>pre_transform</code>, <code>transform_children</code> and
<code>post_transform</code>. However, while <code>transform</code> calls
<code>pre_transform</code> on itself, it calls <code>transform_children</code>
and <code>post_transform</code> on the node returned by
<code>pre_transform</code>. If <code>pre_transform</code> returns a vector,
<code>transform</code> calls <code>transform_children</code> and
<code>post_transform</code> on every element in that vector, assembling all the
results. </para>

<para> <code>pre_transform</code> and <code>post_transform</code> simply call
the appropriate method in the <code>Tree_transform</code> object.  However, if
<code>pre_transform</code> (or <code>post_transform</code>) returns a list of
nodes, the corresponding method in the tree transform object will expect two
arguments: the node to be transformed, and an empty list of nodes that will be
the return value of <code>pre_transform</code>. In that case,
<code>pre_transform</code> will first create a new empty list, pass that in as
the second argument to the corresponding method in the tree transform object,
and then return that list. </para>

<para> <code>transform_children</code> just calls the corresponding method in
the tree transform object. </para>

</section>
</chapter>
