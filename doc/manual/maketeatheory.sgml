<chapter id="maketeatheory">
<title id="maketeatheory.title"><application>Maketea</application> Theory</title>

<section>
<title>Introduction</title>

<para> <application>maketea</application> is a tool bundled with &phc which,
based on a grammar definition of a language, generates a C++ hierarchy for the
corresponding abstract syntax tree, a tree transformation and visitor API, and
deep cloning, deep equality and pattern matching on the AST. In this document
we describe the grammar formalism used by &phc, how a C++ class structure is
derived from such a grammar, and explains how the tree transformation API is
generated. The generated code itself is explained in <xref
linkend="generatedcode" endterm="generatedcode.title">. </para>

</section>
<section>

<title>The Grammar Formalism</title>

<para> The style of grammar formalism used by
<application>maketea</application> is sometimes referred to as an &ldquo;object
oriented&rdquo; context free grammar.  It facilitates a trivial and reliable
mapping between the grammar (<xref linkend="grammar">, and the actual (C++)
abstract syntax tree (AST) that is generated by the &phc parser.  </para>

<para> We make a distinction between three types of symbols:
<emphasis>non-terminal</emphasis> symbols, <emphasis>terminal
symbols</emphasis> and <emphasis>markers</emphasis>.  Non-terminal symbols have
the same function in our formalism as in the usual BNF formalism, and will not
be further explained. We denote non-terminal symbols in lower case in the
grammar (e.g., <code>expr</code>).  </para>

<para> The distinction between terminal symbols and markers is non-standard.
Markers have no semantic value other than their presence; an example is
<code>"abstract"</code>. Thus, the semantic value of a marker is a boolean
value; it is either there, or it is not (note that this is different from a
symbol such as the semi-colon, which has <emphasis>no</emphasis> semantic value
whatsoever, and thus does not need to be included in an abstract syntax tree).
Conversely, the semantic value of a <emphasis>terminal symbol</emphasis> is an
arbitrary value; an example is <code>CLASS_NAME</code> (the structure of a
terminal symbol may be defined by a regular expression; this is irrelevant as
far as the abstract grammar is concerned). We denote markers in quotes
(<code>"abstract"</code>), and terminal symbols in capitals
(<code>CLASS_NAME</code>).  </para>

<para> Each non-terminal symbol <code>a</code> will have a single production in
the grammar.  Instances of <code>a</code> in the AST will be represented by a
class called <code>AST_a</code>.  The attributes of <code>AST_a</code> will
depend on the production for <code>a</code> (see below). </para>

<para> A terminal symbol <code>x</code> will be represented by a class
<code>Token_x</code>. Every token class gets an attribute called
<code>value</code>. The type of this attribute depends on the token; for most
tokens it is <code>String*</code> (this is the default); however, if the
grammar explicitely specifies a type for the value (in angular brackets, for
example <code>REAL&lt;double&gt;</code>), this overrides the default. If the
default value is overridden, the token class gets an additional attribute
<code>source_rep</code>, which corresponds to the value of the token in the
source value. The type of <code>source_rep</code> is always
<code>String*</code>. If the type of the <code>value</code> attribute it set to
be empty, the token class does not get a value but (but it will get a
<code>source_rep</code> field).  </para>

<para> Finally, a marker will not be represented by a specialised class.
Instead, a marker <code>"foo"</code> may <emphasis>only</emphasis> appear as an
optional symbol in a production rule (<code>a ::= ... "foo"? ...</code>), and
will appear as a boolean attribute <code>is_foo</code> in the class
representing <code>a</code> (<code>AST_a</code>).  </para>

<para> There are only two types of rules in the grammar. The first is the
simplest, and list a number of alternatives for a non-terminal symbol
<code>a</code>: </para>

<programlisting>
a ::= b | c | ... | z
</programlisting>

<para> Here, each of <code>b</code>, <code>c</code>, ..., <code>z</code> must
be a single non-terminal symbol.  This rule results in a (usually) empty
<code>class AST_a {}</code>, which acts as a superclass for the classes for
<code>b</code>, <code>c</code>, ..., <code>z</code>. This reflects the
semantics of the rule (a <code>b</code> <emphasis>is</emphasis> an
<code>a</code>); if there are multiple rules <code>a ::= c|...</code>, <code>b
::= c|...</code>, class <code>AST_c</code> will inherit from both
<code>AST_a</code> and <code>AST_b</code>. This type of rule is exemplified by
the production for <code>statement</code> in the grammar. There is one
additional requirement for disjunction rules, which will be explained in the
section on context resolution, below.  </para>

<para> The second type is the most common: </para>

<programlisting>
a ::= b c ... z
</programlisting>

<para> In this rule, each of the <code>b</code>, <code>c</code>, ...,
<code>z</code> is an arbitrary symbol (non-terminal, terminal or marker), which
may be optional (<code>b?</code>) or repeated (<code>b*</code> or
<code>b+</code>). This type of rule must not include any disjunctions
(<code>a|b</code>), and only single symbols can be repeated (no grouping). If a
symbol <code>b</code> can be repeated, it will be represented by a specialised
list class <code>AST_list_b</code> (which inherits from the STL
<code>list</code> class) in the tree. In addition, the symbols may be labeled
(<code>label:symbol</code>). This does not add to the grammar structure, but
explains the purpose of the symbol in the rule, and will be used for the name
of the attribute of the corresponding class.  The default name for each class
attribute depends on the corresponding type: an attribute of type
<code>AST_variable_name</code>  (corresponding to a non-terminal
<code>variable_name</code>) will be called <code>variable_name</code>. The
default name for an attribute of type <code>AST_foo_list</code> will be
<emphasis>foos</emphasis>.  However, as mentioned above, this can be overridden
by specifying a label.  </para>

<para> As an example, consider the rule for <code>variable</code> in the
grammar.  </para>

<programlisting>
expr ::= ... | variable | ... ;
variable ::= target? variable_name <emphasis>array_indices</emphasis>:expr?* <emphasis>string_index</emphasis>:expr? ;
</programlisting>

<para> A <code>variable</code> is an <code>expr</code>, so that
<code>variable</code> is represented by the class shown below. The optionality
of <code>string_index</code> is not reflected directly in the class definition,
but simply means that the <code>string_index</code> field in the class may be
NULL.  </para>

<programlisting>
<reserved>class</reserved> AST_variable : <reserved>virtual public</reserved> AST_expr
{
<reserved>public</reserved>:
   AST_target* target;
   AST_variable_name* variable_name;
   AST_expr_list* array_indices;
   AST_expr* string_index;
}
</programlisting>

<para> A final note on combining <code>*</code> and <code>?</code>. The
construct <code>(a*)?</code> denotes an optional list of <code>a</code>s. Thus,
it will be represented by an <code>AST_a_list</code>. If a list is specified,
but empty, the list will simply contain no elements. If the list is not
specified at all, the list will be NULL. This is used, for example, to
distinguish between methods that contain no statements and abstract methods.
Similarly, <code>(a?)*</code> is a (non-optional) list of optional
<code>a</code>s. Thus, this is a list, but elements of the list may be NULL.
This is used for example to denote empty array indices (<code>a[]</code>) in
the rule for <code>variable</code>.  </para>

</section>
<section id="contextresolution">

<title id="contextresolution.title">Context Resolution</title>

<para> We also derive the tree visitor API and tree transformation API from the
grammar. The tree visitor API is very simple to derive; see the <xref
linkend="generatedcode" endterm="generatedcode.title"> for an explanation. The
tree transformation API however is slightly more difficult to derive. The
problem is to decide the signatures for the transform methods, or in other
words, what can transform into what? For example, in the &phc grammar for PHP,
the transform for an if-statement should be allowed return a list of statements
of any kind (because it is safe to replace an if-statement by a list of
statements).  Similarly, a binary operator should be allowed return any other
expression (but not a list of them). For reasons that will become clear very
soon, we call the process of deciding these signatures &ldquo;context
resolution&rdquo;. </para>

<section>

<title>Contexts</title>

<para> A context is essentially a use of a symbol somewhere in a (concrete)
rule in the grammar.  There are four possibilities. Consider: </para>

<programlisting>
concrete1 ::= ... 
concrete2 ::= ...
concrete3 ::= ...
concrete4 ::= ...
concrete5 ::= ...
concrete6 ::= ...
abstract1 ::= concrete3 | concrete4
abstract2 ::= concrete5 | concrete6
	
some_concrete_rule ::= concrete1 concrete2* abstract1 abstract2* 
</programlisting>

<para> then, based on the rule for some_concrete_rule, concrete1 occurs in the
context (concrete1,concrete1,Single) - i.e., as a single instance of itself,
concrete2 occurs in the context (concrete2,concrete2,List), i.e.  as a list of
instances of itself. The use of the abstract1 class leads to a number of
contexts: </para>

<programlisting>
(abstract1,abstract1,Single)
(concrete3,abstract1,Single)
(concrete4,abstract1,Single)
</programlisting>

<para> And finally, the use of abstract2* yields to the contexts </para>

<programlisting>
(abstract2,abstract2,List)
(concrete5,abstract2,List)
(concrete6,abstract2,List)
</programlisting>

<para> These contexts essentially mean that an instance of concrete5 can be
replaced by any number of any (concrete) instance of "abstract2". </para>

</section>
<section>

<title>Reducing Contexts</title>

<para> If there are two or more conflicting contexts for a single symbol, we
must resolve the contexts to their most specific (restrictive) form.  For
instance, for the &phc grammar, this yields </para>

<programlisting>
(if,statement,List)
(CLASS_NAME,CLASS_NAME,Single)
(INTERFACE_NAME,INTERFACE_NAME,Single)
</programlisting>

<para>So, a context is a triplet (symbol,symbol,multiplicity), where the
symbols are terminal or non-terminal symbols, and the multiplicity is either
Single, Optional, List, OptionalList or ListOptional (list of optionals).  When
reducing two contexts (<code>a</code>,<code>b</code>,<code>c</code>)
(<code>a'</code>,<code>b'</code>,<code>c'</code>), we take the meet of
<code>b</code> and <code>b'</code> (that is, the most general common subclass
of <code>b</code> and <code>b'</code>, where more general means higher up in
the inheritance hierarchy), and opt for the most restrictive Multiplicity
(Single over Optional, Single over List, etc.). The general idea is that we
want the most permissive context for a non-terminal that is still safe: if it
is safe to replace an <code>a</code> by a list of <code>b</code>s
<emphasis>everywhere</emphasis> in a tree, the context we want for
<code>a</code> is (<code>a</code>, <code>b</code>, list). </para>

<para>To see the reason for taking the meet, consider this fragment of the &phc
grammar:</para>

<programlisting>
expr ::= ... | BOOL
cast ::= CAST expr
method_invocation ::= target ...
target ::= expr | CLASS_NAME
</programlisting>

<para>The use of "expr" in the rule for cast leads to the context
(BOOL,expr,Single) The use of "target" in the rule for method_invocation leads
to the context (BOOL,target,Single). By taking the meet of "expr" and "target",
this gives the context (BOOL,expr,Single). This means that it is always safe to
replace a boolean by any other expression (but it is not always safe to replace
a boolean by any other <emphasis>target</emphasis>). </para>
	
<para>In the case of CLASS_NAME, we have the contexts</para>

<programlisting>
(CLASS_NAME,class_name,Single)
(CLASS_NAME,target,Single)
</programlisting>

<para>The meet of class_name and target does not exist; hence this gives the
context</para>
	
<programlisting>
(CLASS_NAME,CLASS_NAME,Single)
</programlisting>

<para> That is, the only safe transformation for CLASS_NAME is from CLASS_NAME
to CLASS_NAME. </para>

<para>To be precise about the &ldquo;most specific&rdquo; multiplicity, here is
a Haskell definition that returns the meet of two multiplicities:</para>

<programlisting>
meet_mult :: Multiplicity -> Multiplicity -> Multiplicity
meet_mult a b | a == b = a
meet_mult Single _ = Single  
meet_mult List Optional = Single 
meet_mult List OptList = List
meet_mult List ListOpt = List
meet_mult Optional OptList = Single
meet_mult Optional ListOpt = Optional
meet_mult OptList ListOpt = List
meet_mult a b = meet_mult b a  <emphasis>-- meet is commutative</emphasis>
</programlisting>

</section>
<section>

<title>Resolution for Disjunctions</title>

<para>We cannot deal with this situation:</para>

<programlisting>
s ::= a
a ::= b | c
d ::= b
e ::= c*
</programlisting>

<para>This grammar leads to the following contexts:</para>

<programlisting>
(a,a,Single)
(b,a,Single)
(b,b,Single)
(c,a,Single)
(c,c,List)
</programlisting>

<para>Resolving these contexts lead to</para>

<programlisting>
(a,a,Single)
(b,b,Single)
(c,c,List)
</programlisting>

<para>However, this is incorrect, because this indicates that an <code>a</code>
will only be replaced by another, single, <code>a</code>; but a <code>c</code>
(which is an <code>a</code>) will in fact return a list of <code>c</code>s. The
problem is that the non-terminals in the rule for <code>a</code> have a
different multiplicity in their contexts (single for <code>b</code>, list for
<code>c</code>). <application>maketea</application> disallows this; if this
happens in a grammar, <application>maketea</application> will exit with a
&ldquo;cannot deal with mixed multiplicity in disjunction&rdquo; error.</para>

<para>Otherwise, for a rule <code>a ::= b1 | b2 | ...</code>, if the
multiplicity of <code>a</code> is list, and the multiplicities of all the
<code>b</code>s are lists, the multiplicity for <code>a</code> will be list; if
the multiplicity of all the <code>b</code>s is single, the multiplicity for
<code>a</code> will be set to single (independent of the original multiplicity
for <code>a</code>).</para>

</section>
</section>
</chapter>
