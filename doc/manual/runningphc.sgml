<chapter id="runningphc">
<title id="runningphc.title">Running &phc</title>

<para> Once you have installed &phc (see <xref linkend="install"
endterm="install.title">), run it by typing </para>

<screen>
phc --help
</screen>
		
<para>
	You should see
</para>

<screen>
phc 0.2.0

Usage: phc [OPTIONS]... [FILES]...

  -h, --help               Print help and exit
      --full-help          Print help, including hidden options, and exit
  -V, --version            Print version and exit

GENERAL OPTIONS:
  -v, --verbose            Verbose output  (default=off)
  -c, --compile            Compile  (default=off)
      --pretty-print       Pretty print input according to the Zend style 
                             guidelines  (default=off)
      --obfuscate          Obfuscate input  (default=off)
      --run=STRING         Run the specified plugin (may be specified multiple 
                             times)
      --r-option=STRING    Pass option to a plugin (specify multiple flags in 
                             the same order as multiple plugins - 1 option only 
                             per plugin)
  -d, --define=STRING      Define ini entry (only affects -c and --include)

INPUT OPTIONS:
      --read-xml=passname  Assume the input is in XML format. Start processing 
                             after the named pass
      --include            Parse included or required files at compile-time  
                             (default=off)

COMPILATION OPTIONS:
  -C, --c-option=STRING    Pass option to the C compile (e.g., -C-g; can be 
                             specified multiple times)
      --extension=NAME     Generate a PHP extension called NAME instead of a 
                             standalone application
  -O, --optimize=STRING    Optimize  (default=`0')
  -o, --output=FILE        Place executable into file FILE
  -e, --execute            Run executable after compiling (implies -c)  
                             (default=off)

PRETTY PRINTING OPTIONS:
      --next-line-curlies  Output the opening curly on the next line instead of 
                             on the same line  (default=off)
      --no-leading-tab     Don't start every line in between <?php .. ?> with a 
                             tab  (default=off)
      --tab=STRING         String to use for tabs while unparsing  
                             (default=`	')
      --no-hash-bang       Do not output any #! lines  (default=off)
</screen>

<para>
	Now write a very small PHP script, for example
</para>

<programlisting>
&lt;? <reserved>echo</reserved> "Hello world!"; ?&gt;
</programlisting>

<para>
	and save it to <filename>helloworld.php</filename>. Then
	run &phc:
</para>

<screen>
phc --pretty-print helloworld.php
</screen>

<para>
	This should output a pretty-printed version of your PHP
	script back to standard output:
</para>
			
<programlisting>
&lt;?<reserved>php</reserved>
   <reserved>echo</reserved> "Hello world!";
?&gt;
</programlisting>

<para>
	You can see a list of options controlling the style of pretty printing, using the
	<code>--full-help</code> option.
</para>

<!-- TODO:
	what can phc do:
		XML
		print canonical form
		run plugins
		combine files
		obfuscate
		warnings
-->
<section>
<title>Compiling executables</title>

<para>
	&phc can compile either executables or extensions. To compile an executable,
	&phc creates C code, which it compiles and links to the PHP embed SAPI.
	Since it links to PHP, you have access to all of PHP's large built-in
	standard library. In order to compile the "hello world" executable from
	before, run
</para>

<screen>
phc -c helloworld.php -o helloworld
</screen>

<para>
	This creates an executable <code>helloworld</code>, which can then be run
</para>

<screen>
./helloworld
</screen>

<para>
	If you prefer to run your executable immediately after it compiles, use the
	<code>-e</code>. &phc will compile your program, then immediately execute
	it. You can also view the C code generated by &phc:
</para>

<screen>
phc --generate-c helloworld.php > helloworld.c
</screen>

<para>
	One of the advantages of &phc is that it can optimize your program. Using
	the <code>-O</code> flag, you can instruct &phc to analyse your source code,
	and perform simple optimizations. On simple benchmarks, this can increase
	the speed of your application by 50%. To optimize:
</para>

<screen>
phc -O2 -c helloworld.php -o helloworld
</screen>

<para>
	&phc generates C code, which is then compiled by <code>gcc</code>. To see
	the command passed to <code>gcc</code> by &phc, use the <code>-v</code>
	flag.
</para>

<para>
	If you
	specify the <code>-O</code> flag, &phc will also pass the <code>-O</code>
	flag to <code>gcc</code>, which will optimize your code further. The
	argument to the <code>-O</code> flag must therefore be usable by
	<code>gcc</code>, so it must be any of <code>-O0</code> (default),
	<code>-O1</code>, <code>-O2</code>, <code>-O3</code> or <code>-Os</code>.
	Consult the <ulink
	url="http://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options">gcc
	manual</ulink> for more details.
</para>

<para>
	It is also possible to pass command-line arguments to <code>gcc</code>
	through &phc, using the <code>-C</code> flag. For example, to disable
	inlining of the generated code by <code>gcc</code>, using
	<code>-fno-inline</code>:
</para>

<screen>
phc -c -O2 helloworld.php -o helloworld -C-fno-inline
</screen>


</section>

<section>
<title>Compiling web applications</title>

<warning>
<para>
	In order to compile web applications, it is currently necessary to alter
	your <filename>php.ini</filename> file, or have access to the root account.
	We welcome suggetions of a different method which avoids these requirements,
	especially if they would work in a shared hosting environment.
</para>
</warning>


<warning>
<para>
	This section is experimental. Please <ulink
	url="http://www.phpcompiler.org/mailinglist.html">report any
	problems</ulink>.
</para>
</warning>

<para>
	We have created the command-line option <code>--web-app</code>, which will
	in the future automate the process of compiling a web application.
	Unfortunately, for now, please follow these steps.
</para>
	
<para>
	We describe how to create and install an extension using the C code
	generated by &phc;. While we give an overview of creating extensions,
	significantly more detail can be found in the <ulink
	url="http://devzone.zend.com/node/view/id/1021">Zend Extension Writing
	Tutorial</ulink> and in <ulink
	url="http://www.amazon.com/dp/067232704X">Extending and Embedding
	PHP</ulink>.
</para>

<para>
	To begin, create a new directory for the extension. We'll use
	<filename>ext/</filename> in our example. Generate C code from
	<filename>helloworld.php</filename> using &phc;.
</para>

<screen>
phc --generate-c helloworld.php > ext/helloworld.c
</screen>

<para>
	Create a new file, <filename>ext/config.m4</filename>, by copying the
	following, and changing instances of "helloworld" appropriately:
</para>

<screen>
PHP_ARG_ENABLE(helloworld, whether to enable Hello World support,
[ --enable-helloworld   Enable Hello World support])

if test "$PHP_HELLOWORLD" = "yes"; then
  AC_DEFINE(HAVE_HELLOWORLD, 1, [Whether you have Hello World])
  PHP_NEW_EXTENSION(helloworld, helloworld.c, $ext_shared)
fi
</screen>

<para>
	In the previous section, we described using the PHP embed SAPI. If you
	installed a copy of PHP with <code>--enable-embed</code> enabled, it is
	important <emphasis>NOT</emphasis> to use that version for the following
	commands.  Instead, you should the same version as your webserver uses. From
	the ext/ directory, run:
</para>

<screen>
phpize --with-php-config=/usr/bin/php-config
./configure --enable-helloworld
</screen>

<para>
	Build and install the extension (if you dont have root, refer instead to
	<xref linkend=alternate.method endterm=alternate.method.title>):
</para>

<screen>
make
sudo make install
</screen>

<para>
	In your web folder, replace the existing <filename>helloworld.php</filename> file contents with the following:
</para>

<screen>
<?php
	dl ("helloworld.so");
	__MAIN__ ();
?>
</screen>

<para>
	If the <code>dl()</code> function is not enabled in your <filename>php.ini</filename> file, enable it:
</para>

<screen>
enable_dl = On;
</screen>

<para>
	Accessing <filename>helloworld.php</filename> should now work. 
</para>



<section id=alternate.method>
<title id=alternate.method.title>Alternatives</title>

<para>
	Instead of setting <code>enable_dl</code>, you can instead load the
	extension manually in your <filename>php.ini</filename> file:
</para>

<screen>
extension=helloworld
</screen>

<para>
	You can also avoid installing the extension using <code>sudo make
	install</code> by adding an alternate extension directory:
</para>

<screen>
extensions_dir="/full/path/to/ext"
</screen>

	
</section>
</section>

<section id="xml">

<title id="xml.title">Writing and Reading XML</title>

<para>
	&phc can output an XML representation of the PHP script. You can use this
	representation if you want to process PHP scripts using tools in your
	desired framework, instead of using &phc plugins. After processing the XML
	representation, &phc can convert it back into PHP. To generate an XML
	version of a PHP script, run
</para>

<screen>
./phc --dump-xml=ast helloworld.php &gt; helloworld.xml
</screen>

<para>
	When reading the XML back in, all the usual features of
	&phc are again available; in particular, it is possible to read an XML file,
	and write PHP syntax. To convert the XML file we just generated back to PHP
	syntax, run
</para>

<screen>
./phc --read-xml=ast --pretty-print helloworld.xml
</screen>

<para>
	The generated XML uses the schema <ulink
	url="http://www.phpcompiler.org/phc-1.0">http://www.phpcompiler.org/phc-1.0</ulink>.
</para>

</section>
<section>
<title>Internal Representations</title>
<para>
	After parsing, &phc; converts a PHP script into an Abstract Syntax Tree
	(AST) (this is further explained in <xref linkend="treetutorial1">). This is
	very useful for processing PHP scripts which you wish to convert back into
	PHP. However, for some tasks, especially program analysis, a simple form of
	the PHP script is more suitable. &phc offers two other Internal
	Representations (IRs). The High-level Internal Representation (HIR)
	simplifies most expressions by assigning them to temporary variables. The
	Medium-level Internal Representation (MIR) converts control-flow statements
	like the <code>for</code>-loop, into <code>goto</code>s. To view PHP in any
	of these forms, use the <code>--dump</code> option:
</para>

<screen>
phc --dump=ast helloworld.php
phc --dump=hir helloworld.php
phc --dump=mir helloworld.php
</screen>

<para>
	Nearly all &phc options work as well on the HIR and MIR as on the AST. For example, XML can be read and written:
</para>

<screen>
phc --dump-xml=hir | ./myprog | phc --read-xml=hir
</screen>

</section>

<section>

<title>Graphical Output</title>

<para>
	If you have a DOT viewer installed on your system (for example, <ulink
	url="http://www.graphviz.org">graphviz</ulink>), you can view the AST
	graphically. First, ask &phc to output the AST in DOT format:
</para>

<screen>
./phc --dump-dot=ast helloworld.php &gt; helloworld.dot
</screen>

<para> You can then view the tree (<filename>helloworld.dot</filename>) using
Graphviz. In most Unix/Linux systems, you should be able to do </para>

<screen>
dotty helloworld.dot
</screen>

<para> And you should see the tree; it should look similar to the tree shown in
figure <xref linkend="helloworldtree">. </para>

<figure id="helloworldtree">
<title>Abstract syntax tree for &ldquo;Hello world&rdquo;</title>
<mediaobject>
<imageobject>
<imagedata fileref="img/helloworld.jpg">
</imageobject>
</mediaobject>
</figure>

</section>
<section>

<title>Including files</title>

<para>
	&phc has initial support for compile-time processing of PHP's
	<code>include</code> built-in.  Enabling this feature inserts the included
	statements in the AST in the place of the <code>include</code> statement.
	Included functions, classes and interfaces become part of the file's
	top-level scope.  In the event that &phc is not able to process the
	<code>include</code> statement (for example, if the file cannot be found), a
	warning is issued, and the <code>include</code> statement is left in place.
	To enable this support, run
</para>

<screen>
./phc --include script_with_includes.php
</screen>

<para> The include support is intended to mimic <ulink
url="http://php.net/manual/en/function.include.php">PHP's include
built-in</ulink>, as far as can be achieved at compile time. &phc supports:
</para>

<itemizedlist>
	<listitem><para>
		Moving included statements to the point at which <code>include</code> was
		called. Naturally, these statement's use the variable scope at the point
		at which they are included,
	</para></listitem>

	<listitem><para>
		Preserving <code>__FILE__</code> and <code>__LINE__</code> statements,
	</para></listitem>

	<listitem><para>
		Moving included functions to the <code>%MAIN%</code> class, and importing
		the included classes,
	</para></listitem>

	<listitem><para>
		<code>include</code>, and <code>require</code>. If the specified file
		cannot be found, parsed, or if the argument to <code>include</code> is
		not a string literal, the include statement is left in
		place.
	</para></listitem>
</itemizedlist>

<para> &phc does not support: </para>

<itemizedlist>
	<listitem><para>
		Return values in included scripts. We intend to support these in the
		future. They will likely be supported in a later stage of the compilation
		process, instead of in the AST,
	</para></listitem>

	<listitem><para>
		Calling <code>include</code> on anything other than a literal string
		containing the filename of a local file. This excludes variables and
		remote files. These may be supported when more static analyses are
		available,
	</para></listitem>

	<listitem><para>
		<code>include_once</code> and <code>require_once</code>, as we cannot
		guarantee that the file to be included is not included elsewhere.  These
		statements will not be processed, and combinations of
		<code>include</code> or <code>require</code> and
		<code>include_once</code> or <code>require_once</code> may cause
		incorrect behaviour with this option set,
	</para></listitem>

	<listitem><para>
		Updating <code>get_included_files()</code> to reflect the included
		files.
	</para></listitem>
</itemizedlist>

</section>
</chapter>
